<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Hight availability in postgresql</title>
    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/pygments.css">
    <script src="/javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
      <h1 class="header"><a href=/>ChinaXing</a></h1>
      <ul>
        <li><a class="buttons github" href="https://github.com/chinaxing">github profile</a></li>
      </ul>
      <p class="header">文章分类
      <a href=/search.htm>
        <img style="float:right;margin:0;margin-top:8px;border:0;padding:0;" 
        src=http://www.google.com/uds/css/v2/search_box_icon.png />
      </a>
      </p>
      <ul>
        
        <li>
        <a href="/categories/linux/">linux</a>
        <span style="float:right">[8]</span>
        </li>
        
        <li>
        <a href="/categories/jekyll/">jekyll</a>
        <span style="float:right">[2]</span>
        </li>
        
        <li>
        <a href="/categories/github/">github</a>
        <span style="float:right">[2]</span>
        </li>
        
        <li>
        <a href="/categories/git/">git</a>
        <span style="float:right">[1]</span>
        </li>
        
        <li>
        <a href="/categories/life/">life</a>
        <span style="float:right">[1]</span>
        </li>
        
        <li>
        <a href="/categories/postgres/">postgres</a>
        <span style="float:right">[2]</span>
        </li>
        
        <li>
        <a href="/categories/django/">django</a>
        <span style="float:right">[1]</span>
        </li>
        
        <li>
        <a href="/categories/Perl/">Perl</a>
        <span style="float:right">[8]</span>
        </li>
        
      </ul>
      </header>
      <section>
      <h1 style="border:0;text-align:center;color:#C3001D;font-weight:bold">
  Hight availability in postgresql
</h1>
<h3 class="no_toc" id="section">目录</h3>
<ul id="markdown-toc">
  <li><a href="#postgresql">Postgresql的数据库备份</a>    <ul>
      <li><a href="#pgdump">使用pg_dump进行备份</a></li>
      <li><a href="#linux">使用linux工具对数据库进行整体备份</a></li>
      <li><a href="#pgbasebackup">使用pg_basebackup</a></li>
    </ul>
  </li>
  <li><a href="#section-1">恢复</a>    <ul>
      <li><a href="#pgdump-1">pg_dump备份的恢复:</a></li>
      <li><a href="#pgbasebackup-1">pg_basebackup备份的恢复:</a></li>
    </ul>
  </li>
  <li><a href="#section-2">热备</a></li>
  <li><a href="#postgres-">postgres 的热备配置:</a>    <ul>
      <li><a href="#slave">热备的slave准备:</a></li>
      <li><a href="#section-3">基于日志归档的配置:</a></li>
      <li><a href="#stream">基于stream的热备配置:</a></li>
      <li><a href="#section-4">两种热备的区别和联系:</a></li>
      <li><a href="#section-5">热备的一致性</a></li>
    </ul>
  </li>
  <li><a href="#replication">复制(replication)</a></li>
  <li><a href="#section-6">其它</a></li>
  <li><a href="#section-7">参考</a></li>
</ul>
<hr />

<p>本文概要: Postgresql 的备份,恢复,热备,复制等机制的说明.</p>

<h3 id="postgresql">Postgresql的数据库备份</h3>

<h4 id="pgdump">使用pg_dump进行备份</h4>

<p>pg_dump类似mysql的mysql_dump工具，可以对数据库中的一个和若干数据库进行备份生成一个sql文件。</p>

<p>pg_dumpall是对整个数据库进行备份。</p>

<p><strong>注意</strong>使用pg_dump生成的备份在恢复后，不能使用原来数据库的archive WAL日志进行replay。</p>

<h4 id="linux">使用linux工具对数据库进行整体备份</h4>

<ol>
  <li>
    <p>在数据库上执行命令: </p>

    <pre><code>select pg_start_backup('备份标签')
</code></pre>

    <p>此步骤让wal的写出变成以记录为单位写，并且执行一次checkpoint，主要是为了wal日志的一致性.</p>
  </li>
  <li>
    <p>使用cp或者tar之类的linux命令工具备份整个数据集群的目录.如:</p>

    <pre><code>tar czf pgsql_DB.tar pgsql_DB  
</code></pre>

    <p>可以不备份pg_xlog下面的文件,而且这个目录下面的日志可能是和备份的数据库不一致的。</p>
  </li>
  <li>
    <p>在数据库上执行命令:</p>

    <pre><code>select pg_stop_backup()
</code></pre>

    <p>此步骤生成一个标记文件,格式为:<code>段名.段内位置.backup</code>，<code>段名</code>表示进行备份时候数据库正写入的wal日志段.通过这个文件可以知道一次备份的位置.</p>

    <p><code>pg_stop_backup()</code>还执行了一次”<strong>段切换</strong>“,切换到新的段,如果设置了归档(archive_mode = on),则等待上一段完成归档。</p>

    <p>这样被归档的段和备份一起构成了一个和当前数据库一致的备份.</p>
  </li>
</ol>

<h4 id="pgbasebackup">使用pg_basebackup</h4>

<p><code>pg_basebackup</code> 命令执行整体备份，作用和上面的<strong>linux工具备份</strong>一样。相对于上一个备份比较容易，不过有一个要求:需要一个具有<code>replication</code>权限的用户，pg_basebackup是用这个用户链接数据库，完成备份。</p>

<h3 id="section-1">恢复</h3>
<p>#### 恢复类型:
1. 若备份采用pg_dump/pg_dumpall 来进行，恢复的时候只能恢复到备份时刻的状态.
2. 若备份使用的是pg_basebackup或者和其功能一样的方法生成的备份,恢复时候可以通过回放wal日志恢复到_“最近”_的状态。</p>

<h4 id="pgdump-1">pg_dump备份的恢复:</h4>
<ol>
  <li>
    <p>新建立数据库: </p>

    <pre><code>pg_ctl init -D pgsql_DB
</code></pre>
  </li>
  <li>
    <p>从备份文件执行备份的sql: </p>

    <pre><code>psql pgdql.backup.sql
</code></pre>
  </li>
</ol>

<h4 id="pgbasebackup-1">pg_basebackup备份的恢复:</h4>
<ol>
  <li>
    <p>解压缩备份: </p>

    <pre><code>tar xzf pgbackup.tar
</code></pre>
  </li>
  <li>
    <p>在数据集目录新建<code>recovery.conf</code>文件,此文件指导postmaster完成恢复:</p>

    <pre><code>cp /usr/local/pgsql/share/recovery.conf.sample pgsql_DB/recovery.conf
</code></pre>
  </li>
  <li>
    <p>编辑此文件,指定归档日志的位置(/home/admin/tmp/pg_archive/):</p>

    <pre><code>restore_command = 'cp /home/admin/tmp/pg_archive/%f %p'
</code></pre>

    <p>postmaster 启动后执行此命令将归档日志copy到pg_xlog目录，然后进行加载回放.</p>

    <p>在recovery.conf 中还可以指定恢复的点，默认是latest(恢复到最近).</p>
  </li>
  <li>归档日志回放完成后(restore_command 返回非0),pgmaster 查找pg_xlog下面的日志，如果有则进行回放。</li>
  <li>所有日志都回放完成。postmaster将recovery.conf改名为recovery.conf.done 然后启动新的postgresql服务器，此时恢复就完成了。
新的服务器可以正常接收请求了。</li>
</ol>

<h3 id="section-2">热备</h3>

<p>热备:warm-standby 和 hot-standby</p>

<p>hot-standby 除了做备份外，还可以提供readonly的查询服务。</p>

<p>热备是指master和slave都处于running状态，master的更新被扩散到slave。slave和master保证一致的状态。当master失效后我们可以启动slave来继续提供服务。</p>

<h3 id="postgres-">postgres 的热备配置:</h3>

<p>posgres的热备有2中方式:</p>

<ul>
  <li>
    <p><strong>基于日志归档和加载的叫做log-ship</strong><br />
故名思议就是将master的日志加载到slave中，从而保证一致。<br />
实现上可以由多种方式，只要master产生wal日志后，copy到slave的pg_xlog下面，slave就会加载。<br />
postgres服务器提供了 archive_command 和 restore_command ，这样我们就只需要配置对这两个命令即可. master 执行archive_command将日志归档到一个地方，slave执行restore_command 目的是拿master的日志到自己手中.</p>

    <p>比如: 如果master和slave在同一台服务器,则只要配置master的归档地址和slave的加载源地址一致即可保证slave与master热备.<br />
 如果master和slave处于2台服务器上，可以配置rsync命令将归档日志移动到slave所在机器等等。实现上非常灵活。</p>
  </li>
  <li>
    <p><strong>基于stream的热备</strong><br />
这种方式是slave和master通过tcp链接slave和master进行replication协议，进行wal记录的同步。<br />
由于采用直接链接，同步状态比较好，一致性高。</p>
  </li>
</ul>

<h4 id="slave">热备的slave准备:</h4>

<p>热备要始于一个起点，从这个起点开始进行主备间的一致性同步（因为之前的日志等已经没有或者根本没有配置），从master产生一个slave必须通过执行一个基础备份来生成。即使用pg_basebackup或者具有相同功能的工具和方法来生成。</p>

<p>如:</p>

<pre><code>pg_basebackup -D pgsql_DB -f t -x -z -l "my backup for slave" -U repl 
</code></pre>

<h4 id="section-3">基于日志归档的配置:</h4>
<ul>
  <li>master 配置:<br />
    <ol>
      <li>postgresql.conf 中设置:<br />
<code>wal_level = archive</code> #日志格式要archive以上.<br />
<code>archive_command = 'cp -i %p /home/admin/tmp/pg_archive3/%f &lt;/dev/null'</code> #日志归档  </li>
    </ol>
  </li>
  <li>slaver 配置:<br />
    <ol>
      <li>recovery.conf 中配置:<br />
<code>standby_mode = on</code> # 此处表示进入slave模式，而不是recovery完成后成为可读可写的库。<br />
<code>restore_command = 'cp /home/admin/tmp/pg_archive/%f %p'</code> # 加载master的归档日志  </li>
    </ol>
  </li>
</ul>

<h4 id="stream">基于stream的热备配置:</h4>

<ul>
  <li>master 配置:<br />
    <ol>
      <li>postgresql.conf 中设置:<br />
<code>wal_level = hot_standby</code> #日志格式必须hot_standby<br />
<code>max_wal_senders = 1</code>  # 此处根据slaver的数量设置  </li>
    </ol>
  </li>
  <li>slaver 配置:<br />
    <ol>
      <li>postgresql.conf 中设置:<br />
<code>hot_standby = on</code> # 此处可选，打开表示slaver上可以执行read-only的查询。默认不可以。  </li>
      <li>recovery.conf 中配置:<br />
<code>standby_mode = on</code> # 此处表示进入slave模式，循环地与master同步。<br />
<code>primary_conninfo = 'host=localhost port=5432 user=repl password=repl_213456'</code> # 使用stream 方式进行同步。  </li>
    </ol>
  </li>
</ul>

<h4 id="section-4">两种热备的区别和联系:</h4>

<p>在postgresql处理热备并不会严格的区分它们。</p>

<p><strong>recovery.conf</strong>是控制热备和恢复的配置。posgresql在启动的时候，如果配置了<code>restore_command</code>,slave则启动加载日志的进程进行加载，</p>

<p>如果加载完成，则进入pg_xlog目录进行加载日志,如果也加载完成，此时查看是否配置了stream方式的复制，</p>

<p>如果配置了，则通过链接与master链接进行接搜日志，如果此步骤失败或者没有配置，</p>

<p>然后根据是否这是了standby_mode 选择退出恢复模式还是继续进行此循环。</p>

<p>如果设置了<code>standby_mode = on</code> 则会循环上面的步骤，可见<strong>log-ship</strong>类型和<strong>stream</strong>类型的复制是同时可以存在的。</p>

<p>如果没有设置<code>standby_mode = on </code>（默认情况）则postgresql在所有尝试都失败(完成)后，认为recovery完成了。将recovery.conf改成recovery.conf.done防止下次重复执行，然后spwan一个新的实例。</p>

<p>通过查看postgresql的启动后进程，可以发现log-ship的工作和stream工作的是由不同进程完成的，因而这两个过程估计是并发进行的。</p>

<h4 id="section-5">热备的一致性</h4>
<p>基于stream的热备比log-ship一致性高，然而基于stream的热备默认是异步的，事务的提交不会等到slave也完成。因而可能存在master上和slave上的不一致性（落后）。</p>

<p>通过在postgresql.conf中设置:synchronous_commit = on 和 synchronous_standby_names=”a,b” 设置复制是同步的。
第一个选项默认是打开的，第二个选项中配置需要同步的slave。</p>

<p>在master将事务写入wal日志后，日志被传输到slave，slave在写入数据库并flush到磁盘后会应答master其写入完成，master收到此应答后才认为此事务完成。</p>

<h3 id="replication">复制(replication)</h3>

<p>复制,replication 可以通过基于stream的热备功能来实现，配置可以直接使用stream热备的配置。</p>

<h3 id="section-6">其它</h3>

<ul>
  <li>查看replication状态: <br />
 在master上的系统view表pg_stat_replication中各个字段</li>
  <li>根据wal日志的location查询对应的段文件:<br />
 select pg_xlogfile_location(‘0/28D09608’);</li>
  <li>
    <p>master正在发送的wal段和slave正在接受的wal段也可以通过查看进程来看到:  </p>

    <p>master:</p>

    <pre><code>  /usr/local/pgsql/bin/postgres -D pgsql_db
   \_ postgres: writer process
   \_ postgres: wal writer process
   \_ postgres: autovacuum launcher process 
   \_ postgres: archiver process   last was 000000010000000000000027
   \_ postgres: stats collector process
   \_ postgres: wal sender process repl 127.0.0.1(19770) streaming 0/28D09728
</code></pre>

    <p>slave:</p>

    <pre><code>  /usr/local/pgsql/bin/postgres -D pgsql_db2
   \_ postgres: startup process   recovering 000000010000000000000028
   \_ postgres: writer process
   \_ postgres: stats collector process
   \_ postgres: admin pesystem [local] idle 
   \_ postgres: wal receiver process   streaming 0/28D09728
</code></pre>
  </li>
</ul>

<h3 id="section-7">参考</h3>
<p><a href="http://www.postgresql.org/docs/devel/static/high-availability.html">http://www.postgresql.org/docs/devel/static/high-availability.html</a></p>



<!---------------------------------------------------------
  ** Google Plus **
  --------------------------------------------------------->
<br>
<!-- Place this tag where you want the +1 button to render. -->
<div class="g-plusone" data-size="medium" ></div>
<!-- google plus -->
<!-- Place this tag after the last +1 button tag. -->
<script type="text/javascript">
  window.___gcfg = {lang: 'zh-CN'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>


<!---------------------------------------------------------
  ** DISQUS **
  --------------------------------------------------------->
<div id="disqus_thread" style="padding-top:1em"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'chinaxing'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

      </section>
      <footer>
      <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
  </body>

  <!-- google Analytics -->
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37422195-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
</html>
