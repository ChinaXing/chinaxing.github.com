---
date: 2015-04-05 01:29:56
template: tech.jade
title: Memory barrier —— 内存屏障
category: Compute
chage_frequency: monthly
tag: CS-Arch
---
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">什么是memory barrier</a></li>
<li><a href="#sec-2">为什么要有memory barrier</a></li>
<li><a href="#sec-3">内存模型</a></li>
<li><a href="#sec-4">memory barrier干什么</a></li>
<li><a href="#sec-5">memory barrier分类</a></li>
<li><a href="#sec-6">Refer</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">什么是memory barrier</h2>
<div class="outline-text-2" id="text-1">
<p>
memory barrier 可以看做是cpu执行内存读写时候插入到读写操作序列中得一个barrier，通过这个barrier，将这些读写序列做了个划分，指示cpu：barrier前的读写序列必须发生在barrier之前，barrier之后的读写序列必须发生在barrier之后。
</p>

<p>
那么也就间接地保证了barrier前后读写操作的顺序。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">为什么要有memory barrier</h2>
<div class="outline-text-2" id="text-2">
<p>
很多人可能奇怪，读写序列不是已经在编写程序的时候写好了吗，为何还要再去要求？
</p>

<p>
这是因为cpu为了提高执行效率，有权利在不影响单线程下顺序正确性的前提下，对指令流进行乱序—— <b>访存指令重排序</b> ，以提高执行效率。
比如：
</p>
<div class="org-src-container">

<pre class="src src-c">a = 20; // 1
d = a * 2; // 2  
b = 30; // 3
c = a + b; // 4
</pre>
</div>
<p>
这段代码，1 3 两行因为没有顺序性要求，可以重排序，比如先执行2后执行1。同理，2 3 两行也没有顺序性要求。
</p>

<p>
因为有 <b>访存重排序</b> 的情况，所以我们写的代码在实际cpu上执行的时候，并不会按照我们指定的顺序执行，cpu会做一些重排优化，但前提是保证语义正确。
</p>

<p>
这在本cpu内执行是没有问题的，但是如果数据要被cpu之外的其它cpu或者设备访问和读写，就会存在问题，因为重排，可能导致外部程序看到的数据状态不是预期的:
</p>
<div class="org-src-container">

<pre class="src src-c">// cpu 1
int a = 2, b = 0;
a = 3; // 2
b = 2; // 3
</pre>
</div>
<div class="org-src-container">

<pre class="src src-c">// cpu 2
x[b] = a; //1
</pre>
</div>
<p>
如果2 3 行被重排序，那么cpu 2的计算结果就存在: <code>x[2] = 2</code> 的情况，而在正常顺序下: <code>x[2] = 3</code> 。
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">内存模型</h2>
<div class="outline-text-2" id="text-3">
<p>
把多处理器上面这种一个cpu内存操作重排序后对其它外部设备和cpu的可见性/承诺，叫做处理器的内存模型，每个处理器都有自己的内存模型说明和保证，在编写并发程序的时候，需要遵循此cpu对其内存模型的保证和申明，才能编写出正确的并发程序。
</p>

<p>
内存模型安装承诺的可见性与代码本身指定的顺序性之间的差异程度，可以分为：weak memory model 与 strong memory model。
</p>
<dl class="org-dl">
<dt> weak/relaxed memory model </dt><dd>指承诺的顺序性很弱，与之伴随的就是重排程度会很大（很宽松），很灵活，处理器自由发挥的余地大，因而往往cpu的效率会相应的高。比如服务器的cpu、Alpha、DEC、powerPC等。
</dd>
<dt> strong memory model </dt><dd>代表对顺序性保证很强，对顺序性的丢失很少，与之伴随的是重排比较少，cpu发挥重排提升性能的空间较小，因此也丧失一定的性能提升，一般在非服务器领域，如：x86 cpu。
</dd>
</dl>

<p>
因为现代的cpu都是分时多任务支持，而且是smp的多cpu多核心架构，势必存在内存模型的问题。因此如果使用非常贴近cpu的语言去编程，一定要考虑好内存model的情况，否则编写的程序可能在比当前平台更weak的平台上运行就会出现并发bug。
</p>

<p>
因而，我们可以知道，通过编译的程序，并不一定能在相同指令集的别的cpu上进行正确运行，因为不同的cpu型号虽然指令集相同，却很可能内存模型不同。
</p>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">memory barrier干什么</h2>
<div class="outline-text-2" id="text-4">
<p>
memory barrier 的目的就是通过一些指令，告知cpu防止某些重排序，而是要保证某些有序性。
</p>

<p>
barrier的前后，就是这种有序性的划界，之前和之后的操作要在barrier上按照时间上有序——不能跨越barrier所处的时间。
</p>

<p>
通过保证有序性，提供多进程之间的协同和同步。
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">memory barrier分类</h2>
<div class="outline-text-2" id="text-5">
<p>
按照读写操作可以分为四类
</p>
<dl class="org-dl">
<dt> LoadLoad </dt><dd>两个load操作之间的发生是有序的，barrier之前的发生于barrier之后的。
</dd>
<dt> StoreStore </dt><dd>两个store之间的有序性发生，barrier之前的写入操作一定发生在barrier之后的。
</dd>
<dt> LoadStore </dt><dd>barrier之前的load操作一定发生在barrier之后的store操作。
</dd>
<dt> StoreLoad </dt><dd>barrier 之前的store操作一定发生在barrier之后的Load操作。这个barrier特别有意义，因为它保证了读取的一定是上次刚刚写入的数据。
</dd>
</dl>

<p>
barrier的支持在不同的cpu上有不同的程度支持，如果本身有支持，那么就不需要强制的插入barrier。
</p>

<p>
barrier的插入可以是cpu提供的指令。
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Refer</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li><a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations/">Memory Barriers Are Like Source Control Operations</a>
</li>
<li><a href="http://preshing.com/20120930/weak-vs-strong-memory-models/">Weak strong memory models</a>
</li>
<li><a href="http://g.oswego.edu/dl/jmm/cookbook.html">Doug Lea Java memory Model</a>
</li>
<li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">The Java Memory Model</a>
</li>
<li><a href="http://www.mjmwired.net/kernel/Documentation/memory-barriers.txt#305">Linux Kernel memory barrier</a>
</li>
<li><a href="http://lwn.net/Articles/262464/">RCU - Read-copy-update</a>
</li>
<li><a href="http://www.amazon.com/gp/product/0123973376/ref=as_li_ss_tl?ie=UTF8&tag=preshonprogr-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0123973376">The art of multiprocessor programming</a>
</li>
</ul>
</div>
</div>
