---
date: 2016-01-09 15:16:39
template: tech.jade
title: Interrupt（中断）
category: Java
chage_frequency: monthly
tag: Java
---
<p>
Java 中的中断通过调用 <code>Thread.interrupt()</code> 方法来进行，那么哪些操作可以被中断呢？
</p>

<p>
可以看该方法的JavaDoc:
</p>
<pre class="example">
/**
 * Interrupts this thread.
 *
 * &lt;p&gt; Unless the current thread is interrupting itself, which is
 * always permitted, the {@link #checkAccess() checkAccess} method
 * of this thread is invoked, which may cause a {@link
 * SecurityException} to be thrown.
 *
 * &lt;p&gt; If this thread is blocked in an invocation of the {@link
 * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
 * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
 * class, or of the {@link #join()}, {@link #join(long)}, {@link
 * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
 * methods of this class, then its interrupt status will be cleared and it
 * will receive an {@link InterruptedException}.
 *
 * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
 * java.nio.channels.InterruptibleChannel InterruptibleChannel}
 * then the channel will be closed, the thread's interrupt
 * status will be set, and the thread will receive a {@link
 * java.nio.channels.ClosedByInterruptException}.
 *
 * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
 * then the thread's interrupt status will be set and it will return
 * immediately from the selection operation, possibly with a non-zero
 * value, just as if the selector's {@link
 * java.nio.channels.Selector#wakeup wakeup} method were invoked.
 *
 * &lt;p&gt; If none of the previous conditions hold then this thread's interrupt
 * status will be set. &lt;/p&gt;
 *
 * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
 *
 * @throws  SecurityException
 *          if the current thread cannot modify this thread
 *
 * @revised 6.0
 * @spec JSR-51
 */
</pre>

<p>
分4种情况：
</p>
<dl class="org-dl">
<dt> block在Object.wait 和 Thread.join/Thread.sleep </dt><dd>触发 <code>InterruptedException</code>, 清除中断状态
</dd>
<dt> block在InterruptibleChannel类型的Channel上 </dt><dd>Channel被关闭，设置中断状态
</dd>
<dt> block在Selector上 </dt><dd>Selector上的阻塞操作马上返回，设置中断状态
</dd>
<dt> 其它情形 </dt><dd>设置中断状态
</dd>
</dl>

<p>
比如，如果在Socket上面的read阻塞操作，在中断的时候，仅仅设置线程的中断状态，而操作不会被中止返回。
</p>

<p>
那么哪些Channel是InterruptibleChannel？ SocketChannel，DatagramChannel，FileChannel都是，基本很多Channel都是可中断的。
</p>

<p>
可中断Channel的实现是怎样的？
</p>

<p>
通过在操作之前插入 <code>begin()</code> 函数来实现的，这个函数定义在 <code>AbstractInterruptibleChannel</code> 中：
</p>
<div class="org-src-container">

<pre class="src src-java">/**
 * Marks the beginning of an I/O operation that might block indefinitely.
 *
 * &lt;p&gt; This method should be invoked in tandem with the {@link #end end}
 * method, using a &lt;tt&gt;try&lt;/tt&gt;&amp;nbsp;...&amp;nbsp;&lt;tt&gt;finally&lt;/tt&gt; block as
 * shown &lt;a href="#be"&gt;above&lt;/a&gt;, in order to implement asynchronous
 * closing and interruption for this channel.  &lt;/p&gt;
 */
protected final void begin() {
    if (interruptor == null) {
        interruptor = new Interruptible() {
                public void interrupt(Thread target) {
                    synchronized (closeLock) {
                        if (!open)
                            return;
                        open = false;
                        interrupted = target;
                        try {
                            AbstractInterruptibleChannel.this.implCloseChannel();
                        } catch (IOException x) { }
                    }
                }};
    }
    blockedOn(interruptor);
    Thread me = Thread.currentThread();
    if (me.isInterrupted())
        interruptor.interrupt(me);
}
</pre>
</div>
<p>
而其原理就是在Thread上面设置hook : <code>blockedOn(interruptor)</code> 函数最终调用Thread的 <code>blockedOn</code> 函数，将回调钩子注册在线程上面。
</p>

<p>
当线程的 <code>interrupt()</code> 方法被调用时，钩子被执行:
</p>
<div class="org-src-container">

<pre class="src src-java">public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
</pre>
</div>

<p>
可中断Channel的这个begin过程为阻塞操作提供了异步中断/关闭的方法，如你自己实现InterruptibleChannel的子类，记得在可以中断的阻塞方法中在阻塞操作之前加入对begin函数的调用：
</p>
<div class="org-src-container">

<pre class="src src-java">// 载录自sun.nio.ch.SocketChannelImpl
public int read(ByteBuffer var1) throws IOException {
    if(var1 == null) {
        throw new NullPointerException();
    } else {
        Object var2 = this.readLock;
        synchronized(this.readLock) {
            if(!this.ensureReadOpen()) {
                return -1;
            } else {
                int var3 = 0;
                boolean var20 = false;

                byte var10000;
                byte var5;
                label356: {
                    int var27;
                    try {
                        var20 = true;
                        this.begin();
</pre>
</div>

<p>
同理，Selector的中断实现也类似:
</p>
<div class="org-src-container">

<pre class="src src-java">// java.nio.channels.spi.AbstractSelector
    protected final void begin() {
        if (interruptor == null) {
            interruptor = new Interruptible() {
                    public void interrupt(Thread ignore) {
                        AbstractSelector.this.wakeup();
                    }};
        }
        AbstractInterruptibleChannel.blockedOn(interruptor);
        Thread me = Thread.currentThread();
        if (me.isInterrupted())
            interruptor.interrupt(me);
    }
</pre>
</div>
<p>
而使用方式：
</p>
<div class="org-src-container">

<pre class="src src-java">// sun.nio.ch.KQueueSelectorImpl
    protected int doSelect(long var1) throws IOException {
        boolean var3 = false;
        if(this.closed) {
            throw new ClosedSelectorException();
        } else {
            this.processDeregisterQueue();

            int var7;
            try {
                this.begin();
</pre>
</div>

<p>
那么其实依赖于Thread本身提供的机制，我们也可以实现对阻塞操作的异步中断，基本原理也就是在进入阻塞前设置好Hook（通过在Thread对象上调用blockedOn方法注册Interruptible对象）.
</p>

<p>
最后, 关于Interrupt的处理,线程应该在合适的地方检察自己的interrupt状态,是否被中断了, 从而感知到某些事件。
</p>
