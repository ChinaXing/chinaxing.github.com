---
date: 2015-02-19 21:05:45
template: tech.jade
title: Erlang Socket编程
category: Erlang
chage_frequency: monthly
tag: Erlang
---
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">TCP Socket</a>
<ul>
<li><a href="#sec-1-1">控制进程</a></li>
<li><a href="#sec-1-2">主动消息模式（active ＝ true）</a></li>
<li><a href="#sec-1-3">被动消息模式（active ＝ false）</a></li>
<li><a href="#sec-1-4">混合消息模式（active ＝ once）</a></li>
</ul>
</li>
<li><a href="#sec-2">UDP Socket</a>
<ul>
<li><a href="#sec-2-1">UDP 多播</a></li>
</ul>
</li>
</ul>
</div>
</div>

<p>
Erlang 提供了 <code>gen_tcp</code> 和 <code>gen_udp</code> 模块，方便进行网络编程。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">TCP Socket</h2>
<div class="outline-text-2" id="text-1">
<p>
<b>TCP</b> ：Transmission Control Protocol
</p>

<p>
Tcp的特点是传输 <b>可靠性</b> ：有序性，完整性。此外为了保证效率，tcp支持流量控制。
</p>

<p>
Tcp传输是面向 <b>字节流</b> 的，最小传输单元是字节，由于是流，所以到达socket的一个片段可能包含的字节数是不确定的，如果采用TCP进行报文传输，需要应用层去判断数据是否全部到达，如果未全部到达，需要缓冲与等候。
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">控制进程</h3>
<div class="outline-text-3" id="text-1-1">
<p>
创建Socket的方法有： <code>gen_tcp:accept</code> 和 <code>gen_tcp:connect</code> ，创建Socket的进程叫做该Socket的控制进程，所有发送给Socket的消息都发送到控制进程：
</p>
<div class="org-src-container">

<pre class="src src-erlang">gen_tcp:controlling_process(Socket,NewPid). %% 修改控制进程为NewPid
</pre>
</div>
<p>
控制进程退出，则Socket自动被关闭，这让错误处理变得简单。Socket关闭会发送 <code>{tcp_closed, Socket}</code> 给对方，使对方关闭Socket。
</p>

<p>
Erlang 允许多个进程同时accept一个Socket。
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">主动消息模式（active ＝ true）</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Socket接收消息非阻塞，不等上层应用fetch，就送达，接收端不可控制发送方的发送。
</p>
<div class="org-src-container">

<pre class="src src-erlang">{ok, Listen} = gen_tcp:listen(Port, [...,{active, true}]), %% active设置为true
....
receive %% 使用receive来接收Socket数据
  {tcp,Socket,Data} -&gt;
    ....
end.
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">被动消息模式（active ＝ false）</h3>
<div class="outline-text-3" id="text-1-3">
<p>
消息不会直接投递到mailbox，接收方主动receive，若不receive，发送方会进入阻塞。
</p>
<div class="org-src-container">

<pre class="src src-erlang">{ok, Listen} = gen_tcp:listen(Port, [...,{active, false}]), %% active设置为false
....
case gen_tcp:recv(Socket,N) of  %% 使用gen_tcp:recv获取数据
     {ok, B} -&gt;
       ...
end
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">混合消息模式（active ＝ once）</h3>
<div class="outline-text-3" id="text-1-4">
<p>
开始时为主动模式，receive一个消息后，自动进入被动模式。
</p>
<div class="org-src-container">

<pre class="src src-erlang">{ok, Listen} = gen_tcp:listen(Port, [...,{active, once}]), %% active设置为once，为主动模式
....
receive %% 使用receive来接收Socket数据
  {tcp,Socket,Data} -&gt; %% 获取到数据之后，Socket进入被动模式
    ....
  inet:setopts(Socket, [{active, once}]) %% 在此处可以改变模式为主动模式，然后继续接收
end.
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">UDP Socket</h2>
<div class="outline-text-2" id="text-2">
<p>
<b>UDP</b> ： User Datagram Protocol
</p>

<p>
Udp的特点是数据报：数据封装为一个报文，写上目标地址，然后投递出去。
</p>

<p>
Udp不关心是否准确投递成功，存在几种可能的情况：
</p>
<dl class="org-dl">
<dt> 未投递成功 </dt><dd>这种情况原因很多，如报文的大小超过路由器的MTU，而被路由器丢弃。
</dd>
<dt> 重复投递 </dt><dd>网络路由存在短暂的路由调整带来的环路，因此最好在发送的Pakcet中包含一个唯一序列号来区别重复，可以使用 <code>make_ref</code> 来生成唯一ID。
</dd>
</dl>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">UDP 多播</h3>
<div class="outline-text-3" id="text-2-1">
<p>
UDP多播需要特殊的UDP地址，UDP多播通常无法跨越局域网，因为绝多数的路由器不会路由UDP多播包。
</p>

<div class="org-src-container">

<pre class="src src-erlang">send(Data) -&gt;
    case inet:ifget("en0", [broadaddr]) of %% 获取多播Ip
	 {ok, [{broadaddr, Ip}]} -&gt;
	    {ok, S} = gen_udp:open(5019, [{broadcast, true}]), %% 多播设置为true
	    gen_udp:send(S,Ip,6000,Data), %% Ip，端口
	    gen_udp:close(S);
	  _ -&gt;
	    io:format("Bad interface name, or\n"
		      "broadcasting not supported\n")
    end.
listen() -&gt;
    {ok, _} = gen_udp:open(6000),
    loop().

loop() -&gt;
    receive
      Any -&gt;
	  io:format("received : ~p~n", [Any]),
	  loop()
    end.
</pre>
</div>
</div>
</div>
</div>
