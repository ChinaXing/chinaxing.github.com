<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Hight availability in postgresql - The Chinaxing's blog
    </title>
    <link rel="stylesheet" href="/css/styles.css">
    <script type="text/javascript" src="/js/index.js"></script>
  </head>
  <body>
    <header id="header">
      <div id="menu">
        <div id="menu-header"><a id="site-name" href="/">ChinaXing</a><a id="github-icon" style="background-image: url(/lambda.png);" title="View Github profile" href="http://github.com/ChinaXing/"></a></div>
        <ul id="menu-list">
          <li><a href="/CS-Arch/index.html">CS-Arch<sup>4</sup></a></li>
          <li><a href="/DS-Al/index.html">DS-Al<sup>1</sup></a></li>
          <li><a href="/Erlang/index.html">Erlang<sup>2</sup></a></li>
          <li><a href="/distribute/index.html">distribute<sup>1</sup></a></li>
          <li><a href="/Haskell/index.html">Haskell<sup>6</sup></a></li>
          <li><a href="/Java/index.html">Java<sup>8</sup></a></li>
          <li class="active"><a href="/Postgres/index.html">Postgres<sup>2</sup></a></li>
          <li><a href="/Life/index.html">Life<sup>6</sup></a></li>
          <li><a href="/Perl/index.html">Perl<sup>22</sup></a></li>
          <li><a href="/Linux/index.html">Linux<sup>26</sup></a></li>
        </ul>
        <!-- vistor map-->
        <div id="clustrmaps-widget"></div>
      </div>
    </header>
    <section id="content">
      <h2 style="text-align:center">Hight availability in postgresql
      </h2>
      <div id="toc">Table of Content
        <ol></ol>
      </div>
      <div class="tech">


<p>
<b>本文概要</b>: Postgresql&nbsp;的备份,恢复,热备,复制等机制的说明.
</p>


<div id="table-of-contents">
<h2>Table of&nbsp;Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Postgresql的数据库备份</a>
<ul>
<li><a href="#sec-1-1">使用pg_dump进行备份</a></li>
<li><a href="#sec-1-2">使用linux工具对数据库进行整体备份</a></li>
<li><a href="#sec-1-3">使用pg_basebackup</a></li>
</ul>
</li>
<li><a href="#sec-2">恢复</a>
<ul>
<li><a href="#sec-2-1">恢复类型</a></li>
<li><a href="#sec-2-2">pg_dump备份的恢复</a></li>
<li><a href="#sec-2-3">pg_basebackup备份的恢复</a></li>
</ul>
</li>
<li><a href="#sec-3">热备</a>
<ul>
<li><a href="#sec-3-1">postgres&nbsp;的热备配置</a></li>
<li><a href="#sec-3-2">热备的slave准备</a></li>
<li><a href="#sec-3-3">基于日志归档的配置</a></li>
<li><a href="#sec-3-4">基于stream的热备配置</a></li>
<li><a href="#sec-3-5">两种热备的区别和联系</a></li>
<li><a href="#sec-3-6">热备的一致性</a></li>
</ul>
</li>
<li><a href="#sec-4">复制(replication)</a></li>
<li><a href="#sec-5">其它</a>
<ul>
<li><a href="#sec-5-1">查看replication</a></li>
<li><a href="#sec-5-2">参考</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-3">
<h3 id="sec-1">Postgresql的数据库备份</h3>
<div class="outline-text-3" id="text-1">



</div>

<div id="outline-container-1-1" class="outline-4">
<h4 id="sec-1-1">使用pg_dump进行备份</h4>
<div class="outline-text-4" id="text-1-1">


<p>
pg_dump类似mysql的mysql_dump工具，可以对数据库中的一个和若干数据库进行备份生成一个sql文件。
</p>
<p>
pg_dumpall是对整个数据库进行备份。
</p>

<p>
<b>注意</b> 使用pg_dump生成的备份在恢复后，不能使用原来数据库的archive&nbsp;<span class="caps">WAL</span>日志进行replay。
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-4">
<h4 id="sec-1-2">使用linux工具对数据库进行整体备份</h4>
<div class="outline-text-4" id="text-1-2">


<ol>
<li>在数据库上执行命令: 



<pre class="example">select pg_start_backup('备份标签')   
</pre>

<p>
   此步骤让wal的写出变成以记录为单位写，并且执行一次checkpoint，主要是为了wal日志的一致性.
</p></li>
<li>使用cp或者tar之类的linux命令工具备份整个数据集群的目录.如:



<pre class="example">tar czf pgsql_DB.tar pgsql_DB     
</pre>

<p>
   可以不备份pg_xlog下面的文件,而且这个目录下面的日志可能是和备份的数据库不一致的。
</p></li>
<li>在数据库上执行命令:



<pre class="example">select pg_stop_backup()   
</pre>

<p>
   此步骤生成一个标记文件,格式为: <span style="text-decoration:underline;">段名.段内位置.backup</span> , <b>段名</b>&nbsp;表示进行备份时候数据库正写入的wal日志段.通过这个文件可以知道一次备份的位置.
</p>
<p>
   <b>pg_stop_backup()</b> 还执行了一次&#8221;<b>段切换</b>&#8220;,切换到新的段,如果设置了归档(archive_mode =&nbsp;on),则等待上一段完成归档。
</p>
<p>
   这样被归档的段和备份一起构成了一个和当前数据库一致的备份.
</p></li>
</ol>


</div>

</div>

<div id="outline-container-1-3" class="outline-4">
<h4 id="sec-1-3">使用pg_basebackup</h4>
<div class="outline-text-4" id="text-1-3">


<p>
<b>pg_basebackup</b> 命令执行整体备份，作用和上面的 <b>linux工具备份</b> 一样。相对于上一个备份比较容易，不过有一个要求: 需要一个具有 <span style="text-decoration:underline;">replication</span> 权限的用户,&nbsp;pg_basebackup用这个用户链接数据库,完成备份。
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2">恢复</h3>
<div class="outline-text-3" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-4">
<h4 id="sec-2-1">恢复类型</h4>
<div class="outline-text-4" id="text-2-1">

<ol>
<li>若备份采用pg_dump/pg_dumpall&nbsp;来进行，恢复的时候只能恢复到备份时刻的状态.
</li>
<li>若备份使用的是pg_basebackup或者和其功能一样的方法生成的备份,恢复时候可以通过回放wal日志恢复到&#8221;<span style="text-decoration:underline;">最近</span>&#8220;的状态。
</li>
</ol>


</div>

</div>

<div id="outline-container-2-2" class="outline-4">
<h4 id="sec-2-2">pg_dump备份的恢复</h4>
<div class="outline-text-4" id="text-2-2">

<ol>
<li>新建立数据库: 



<pre class="example">pg_ctl init -D pgsql_DB   
</pre>

</li>
<li>从备份文件执行备份的sql: 



<pre class="example">psql pgdql.backup.sql   
</pre>

</li>
</ol>

</div>

</div>

<div id="outline-container-2-3" class="outline-4">
<h4 id="sec-2-3">pg_basebackup备份的恢复</h4>
<div class="outline-text-4" id="text-2-3">

<ol>
<li>解压缩备份: 



<pre class="example">tar xzf pgbackup.tar
</pre>

</li>
<li>在数据集目录新建 <span style="text-decoration:underline;">recovery.conf</span> 文件, 此文件指导postmaster完成恢复:



<pre class="example">cp /usr/local/pgsql/share/recovery.conf.sample pgsql_DB/recovery.conf   
</pre>

</li>
<li>编辑此文件,指定归档日志的位置(<i>home/admin/tmp/pg_archive</i>):



<pre class="example">restore_command = 'cp /home/admin/tmp/pg_archive/%f %p'
</pre>

<p>
   postmaster&nbsp;启动后执行此命令将归档日志copy到pg_xlog目录，然后进行加载回放.
</p>
<p>
   在recovery.conf&nbsp;中还可以指定恢复的点，默认是latest(恢复到最近).
</p>
</li>
<li>归档日志回放完成后(restore_command 返回非0),&nbsp;pgmaster查找pg_xlog下面的日志，如果有则进行回放。
</li>
<li>所有日志都回放完成。 
   postmaster将recovery.conf改名为recovery.conf.done 然后启动新的postgresql服务器，此时恢复就完成了。&nbsp;新的服务器可以正常接收请求了。
</li>
</ol>


</div>
</div>

</div>

<div id="outline-container-3" class="outline-3">
<h3 id="sec-3">热备</h3>
<div class="outline-text-3" id="text-3">


<p>
<b>热备</b>: warm-standby 和&nbsp;hot-standby
</p>
<p>
hot-standby&nbsp;除了做备份外，还可以提供readonly的查询服务。
</p>
<p>
热备是指master和slave都处于running状态，master的更新被扩散到slave。slave和master保证一致的状态。当master失效后我们可以启动slave来继续提供服务。
</p>

</div>

<div id="outline-container-3-1" class="outline-4">
<h4 id="sec-3-1">postgres&nbsp;的热备配置</h4>
<div class="outline-text-4" id="text-3-1">


<p>
posgres的热备有2中方式:
</p>
<ol>
<li>基于日志归档和加载的叫做log-ship
   故名思议就是将master的日志加载到slave中，从而保证一致。  

<p>
   实现上可以由多种方式，只要master产生wal日志后，copy到slave的pg_xlog下面，slave就会加载。  
</p>
<p>
   postgres服务器提供了 archive<sub>command</sub> 和 restore<sub>command</sub> ，这样我们就只需要配置对这两个命令即可. master 执行archive<sub>command将日志归档到一个地方，slave执行restore</sub><sub>command</sub> 目的是拿master的日志到自己手中.
</p>
<p>
   比如:&nbsp;如果master和slave在同一台服务器,则只要配置master的归档地址和slave的加载源地址一致即可保证slave与master热备.  
</p>
<p>
   如果master和slave处于2台服务器上，可以配置rsync命令将归档日志移动到slave所在机器等等。实现上非常灵活。
</p></li>
<li>基于stream的热备
  这种方式是slave和master通过tcp链接slave和master进行replication协议，进行wal记录的同步。  

<p>
  由于采用直接链接，同步状态比较好，一致性高。
</p></li>
</ol>


</div>

</div>

<div id="outline-container-3-2" class="outline-4">
<h4 id="sec-3-2">热备的slave准备</h4>
<div class="outline-text-4" id="text-3-2">


<p>
热备要始于一个起点，从这个起点开始进行主备间的一致性同步（因为之前的日志等已经没有或者根本没有配置），从master产生一个slave必须通过执行一个基础备份来生成。即使用pg_basebackup或者具有相同功能的工具和方法来生成。
</p>
<p>
如:
</p>


<pre class="example">pg_basebackup -D pgsql_DB -f t -x -z -l "my backup for slave" -U repl    
</pre>


</div>

</div>

<div id="outline-container-3-3" class="outline-4">
<h4 id="sec-3-3">基于日志归档的配置</h4>
<div class="outline-text-4" id="text-3-3">

<ul>
<li>master 配置:  
<ol>
<li>postgresql.conf 中设置:  



<pre class="example">#日志格式要archive以上.  
wal_level = archive
#日志归档       
archive_command = 'cp -i %p ~/pg_archive3/%f &lt;/dev/null'
</pre>

</li>
</ol>

</li>
<li>slaver 配置:  
<ol>
<li>recovery.conf 中配置:  



<pre class="example"># 此处表示进入slave模式，而不是recovery完成后成为可读可写的库。  
standby_mode = on 
# 加载master的归档日志       
restore_command = 'cp ~/pg_archive/%f %p'
</pre>

</li>
</ol>

</li>
</ul>


</div>

</div>

<div id="outline-container-3-4" class="outline-4">
<h4 id="sec-3-4">基于stream的热备配置</h4>
<div class="outline-text-4" id="text-3-4">

<ul>
<li>master 配置:  
<ol>
<li>postgresql.conf 中设置:  



<pre class="example">#日志格式必须hot_standby  
wal_level = hot_standby
# 此处根据slaver的数量设置       
max_wal_senders = 1
</pre>

</li>
</ol>

</li>
<li>slaver 配置:  
<ol>
<li>postgresql.conf 中设置:  



<pre class="example"># 此处可选，打开表示slaver上可以执行read-only的查询,默认不可以
hot_standby = on 
</pre>

</li>
<li>recovery.conf 中配置:  



<pre class="example"># 此处表示进入slave模式，循环地与master同步
standby_mode = on
# 使用stream 方式进行同步
primary_conninfo = 'host=localhost port=5432 user=repl password=repl_213456'
</pre>

</li>
</ol>

</li>
</ul>

</div>

</div>

<div id="outline-container-3-5" class="outline-4">
<h4 id="sec-3-5">两种热备的区别和联系</h4>
<div class="outline-text-4" id="text-3-5">


<p>
postgresql处理热备并不会严格的区分它们。
</p>
<p>
<b>recovery.conf</b>&nbsp;是控制热备和恢复的配置。
</p>
<p>
posgresql在启动的时候，如果配置了 <b>restore<sub>command</sub></b>,&nbsp;slave则启动加载日志的进程进行加载，
</p>
<p>
如果加载完成，则进入pg_xlog目录进行加载日志,如果也加载完成，此时查看是否配置了stream方式的复制，
</p>
<p>
如果配置了，则通过链接与master链接进行接搜日志，如果此步骤失败或者没有配置，
</p>
<p>
然后根据是否这是了standby_mode&nbsp;选择退出恢复模式还是继续进行此循环。
</p>
<p>
如果设置了 <b>standby_mode = on</b> 则会循环上面的步骤，可见 <b>log-ship</b> 类型和 <b>stream</b>&nbsp;类型的复制是同时可以存在的。
</p>
<p>
如果没有设置 <b>standby_mode = on</b>&nbsp;（默认情况）则postgresql在所有尝试都失败(完成)后，认为recovery完成了。将recovery.conf改成recovery.conf.done防止下次重复执行，然后spwan一个新的实例。
</p>
<p>
通过查看postgresql的启动后进程，可以发现log-ship的工作和stream工作的是由不同进程完成的，因而这两个过程估计是并发进行的。
</p>
</div>

</div>

<div id="outline-container-3-6" class="outline-4">
<h4 id="sec-3-6">热备的一致性</h4>
<div class="outline-text-4" id="text-3-6">

<p>基于stream的热备比log-ship一致性高，然而基于stream的热备默认是异步的，事务的提交不会等到slave也完成。因而可能存在master上和slave上的不一致性（落后）。
</p>
<p>
通过在postgresql.conf中设置: synchronous_commit = on 和 synchronous_standby_names=&#8221;a,b&#8221; 设置复制是同步的。&nbsp;第一个选项默认是打开的，第二个选项中配置需要同步的slave。
</p>
<p>
在master将事务写入wal日志后，日志被传输到slave，slave在写入数据库并flush到磁盘后会应答master其写入完成，master收到此应答后才认为此事务完成。
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-3">
<h3 id="sec-4">复制(replication)</h3>
<div class="outline-text-3" id="text-4">

<p>复制,replication&nbsp;可以通过基于stream的热备功能来实现，配置可以直接使用stream热备的配置。
</p></div>

</div>

<div id="outline-container-5" class="outline-3">
<h3 id="sec-5">其它</h3>
<div class="outline-text-3" id="text-5">


</div>

<div id="outline-container-5-1" class="outline-4">
<h4 id="sec-5-1">查看replication</h4>
<div class="outline-text-4" id="text-5-1">

<p>   在master上的系统view表pg_stat_replication中各个字段
</p><ul>
<li>根据wal日志的location查询对应的段文件



<pre class="example">select pg_xlogfile_location('0/28D09608');   
</pre>

</li>
<li>master正在发送的wal段和slave正在接受的wal段也可以通过查看进程来看到
    master:



<pre class="example">/usr/local/pgsql/bin/postgres -D pgsql_db
 \_ postgres: writer process
 \_ postgres: wal writer process
 \_ postgres: autovacuum launcher process 
 \_ postgres: archiver process   last was 000000010000000000000027
 \_ postgres: stats collector process
 \_ postgres: wal sender process repl 127.0.0.1(19770) streaming 0/28D09728
</pre>

<p>
    slave:
</p>


<pre class="example">/usr/local/pgsql/bin/postgres -D pgsql_db2
 \_ postgres: startup process   recovering 000000010000000000000028
 \_ postgres: writer process
 \_ postgres: stats collector process
 \_ postgres: admin pesystem [local] idle 
 \_ postgres: wal receiver process   streaming 0/28D09728    
</pre>

</li>
</ul>


</div>

</div>

<div id="outline-container-5-2" class="outline-4">
<h4 id="sec-5-2">参考</h4>
<div class="outline-text-4" id="text-5-2">

<p><a href="http://www.postgresql.org/docs/devel/static/high-availability.html">http://www.postgresql.org/docs/devel/static/high-availability.html</a>
</p></div>
</div>
</div>

      </div>
      <!-- Table of Content-->
      <script src="/js/jquery-1.11.1.min.js" charset="utf-8"></script>
      <script src="/js/tableofcontents.js" charset="utf-8"></script>
      <script charset="utf-8">
        $(function(){
          $("#toc>ol").tableOfContents(
           null,
           {
             startLevel: 3,
             depth:3,
             topLinks: "\u21E7",
             topLinkClass: "toc-top-link",
             topBodyId: "toc-top",
          });
        });
        
      </script>
      <!-- Google Plus--><br>
      <!-- Place this tag where you want the +1 button to render.-->
      <div data-size="medium" class="g-plusone"></div>
      <!--google plus-->
      <!-- Place this tag after the last +1 button tag.-->
      <script>
        window.___gcfg = {lang: 'zh-CN'};
        
        (function() {
          var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
          po.src = 'https://apis.google.com/js/plusone.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
        
        
      </script>
      <!-- DISQUS-->
      <div id="disqus_thread" style="padding-top:1em"></div>
      <script>
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'chinaxing'; // required: replace example with your forum shortname
        
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
        
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript><a id="dsq-brlink" href="http://disqus.com">comments powered by<span class="logo-disqus">Disqus</span></a>
    </section>
    <footer>
    </footer>
  </body>
  <!-- google Analytics-->
  <script>
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37422195-1']);
    _gaq.push(['_trackPageview']);
    
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <!-- clusterMaps-->
  <script>
    var _clustrmaps = {
     'url' : 'http://chinaxing.org', 
     'user' : 1103575, 
     'server' : '2',
     'id' : 'clustrmaps-widget', 
      'version' : 1, 
     'date' : '2013-07-14',
     'lang' : 'zh',
     'corners' : 'square' 
    };
    (function (){
      var s = document.createElement('script'); 
      s.type = 'text/javascript'; 
      s.async = true; 
      s.src = 'http://www2.clustrmaps.com/counter/map.js'; 
      var x = document.getElementsByTagName('script')[0]; 
      x.parentNode.insertBefore(s, x);})();
  </script>
  <noscript>
    a(href="http://www2.clustrmaps.com/user/f0710d6d7")
      img(src="http://www2.clustrmaps.com/stats/maps-no_clusters/chinaxing.org-thumb.jpg", alt="Locations of visitors to this page")
  </noscript>
</html>