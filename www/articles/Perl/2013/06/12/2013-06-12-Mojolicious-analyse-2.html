<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Mojolicious Web框架实现分析 -- 请求处理过程 - The Chinaxing's blog
    </title>
    <link rel="stylesheet" href="/css/styles.css">
    <script type="text/javascript" src="/js/index.js"></script>
  </head>
  <body>
    <header id="header">
      <div id="menu">
        <div id="menu-header"><a id="site-name" href="/">ChinaXing</a><a id="github-icon" data-icon="&#xf00a" title="View Github profile" href="http://chinaxing.org"></a></div>
        <ul id="menu-list">
          <li><a href="/Java/index.html">Java<sup>6</sup></a></li>
          <li><a href="/Life/index.html">Life<sup>2</sup></a></li>
          <li><a href="/Linux/index.html">Linux<sup>23</sup></a></li>
          <li class="active"><a href="/Perl/index.html">Perl<sup>22</sup></a></li>
          <li><a href="/Postgres/index.html">Postgres<sup>2</sup></a></li>
          <li><a href="/Python/index.html">Python<sup>1</sup></a></li>
        </ul>
        <!-- vistor map-->
        <div id="clustrmaps-widget"></div>
      </div>
    </header>
    <section id="content">
      <h2 style="text-align:center">Mojolicious Web框架实现分析 -- 请求处理过程
      </h2>
      <div id="toc">Table of Content
        <ol></ol>
      </div>
      <div class="tech">

<p>
Mojolicious&nbsp;是基于事件的web框架，那么如何知道请求这个事件发生了呢？
</p>
<p>
由于请求是通过网络上达到，通过Client对server监听的端口发起链接而产生，这一事件是accept事件，Mojolicious得知这一事件的方法有两种:
</p><ul>
<li>使用<span class="caps">IO</span>::Poll 模块，隔一段时间进行一次轮询，问内核:是否有链接了？&nbsp;这个轮询是被ioloop-&gt;start所启动
</li>
<li>使用<span class="caps">EV</span>模块，&nbsp;注册一个回调函数，在链接到达的时候，这个回调函数会被EV模块调用．
</li>
</ul>


<p>
不论哪种方式(主动查询还是被动通告)，当一个socket上的accept事件发生的时候，Mojolicious被唤醒
</p><ul>
<li><span class="caps">IO</span>::Pool模式
  此模式下轮询函数是Mojo::Reactor::one_tick方法，可以看到当可读/写发生时候，调用:



<pre class="src src-perl">++$i <span style="color: #ff7f50;">and</span> $self-&gt;_sandbox(<span style="color: #ffff00;">'Write'</span>&#65292; $self-&gt;{<span style="color: #ffff00;">io</span>}{<span style="color: #ff7f50;">fileno</span> $_}{<span style="color: #ffff00;">cb</span>}&#65292; 1)
</pre>

</li>
<li><span class="caps">EV</span>模式
  _io方法会被调用，进而调用注册的回调:



<pre class="src src-perl"><span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$io</span> = $self-&gt;{<span style="color: #ffff00;">io</span>}{$fd};
$self-&gt;_sandbox(<span style="color: #ffff00;">'Read'</span>&#65292; $io-&gt;{<span style="color: #ffff00;">cb</span>}&#65292; 0) <span style="color: #00ffff;">if</span> <span class="caps">EV</span>::READ &amp;$revents;
</pre>

</li>
</ul>


<p>
因此从处理函数被调用开始分析一个请求的处理过程
</p>

<div id="table-of-contents">
<h2>Table of&nbsp;Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 请求处理过程</a>
<ul>
<li><a href="#sec-1-1">1.1 listen&nbsp;socket上面的回调</a></li>
<li><a href="#sec-1-2">1.2 listen&nbsp;socket上链接达到</a></li>
<li><a href="#sec-1-3">1.3&nbsp;为链接创建Mojo::IOLoop::Stream</a></li>
<li><a href="#sec-1-4">1.4&nbsp;client发来数据</a></li>
<li><a href="#sec-1-5">1.5&nbsp;transaction被创建并处理数据</a></li>
<li><a href="#sec-1-6">1.6&nbsp;数据分析完整触发tx上的request事件</a></li>
<li><a href="#sec-1-7">1.7&nbsp;执行app上的handler方法</a></li>
<li><a href="#sec-1-8">1.8&nbsp;tx被唤醒写response数据到链接</a></li>
<li><a href="#sec-1-9">1.9&nbsp;结束tx</a></li>
</ul>
</li>
<li><a href="#sec-2">2&nbsp;总结</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-3">
<h3 id="sec-1">请求处理过程</h3>
<div class="outline-text-3" id="text-1">



</div>

<div id="outline-container-1-1" class="outline-4">
<h4 id="sec-1-1">listen&nbsp;socket上面的回调</h4>
<div class="outline-text-4" id="text-1-1">

<p>   socket对应fd上面的回调， 这个回调在哪注册的呢？<br/>&nbsp;Mojo::IOLoop在创建server实例的时候，创建完毕会执行一个:
</p>


<pre class="src src-perl"><span style="color: #00ffff;">return</span> $self-&gt;acceptor($server);
</pre>

<p>
     来将$server实例记录在$self-&gt;{acceptors}中，最后执行:
</p>


<pre class="src src-perl"><span style="color: #ff0000;"># </span><span style="color: #ff0000;">Stop accepting so new acceptor can get picked up</span>
$self-&gt;_not_accepting;
</pre>

<p>
     这里释放accept锁，表示其他进程的server可以进行注册accept处理函数到accept的socket．<br/>&nbsp;在释放锁的同时，注意到_not_accepting函数内首先启动了一个定时器:
</p>


<pre class="src src-perl">$self-&gt;_timers;
&#65294;&#65294;&#65294;
<span style="color: #00ffff;">sub</span> <span style="color: #4186be;">_timers</span> {
      <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$self</span> = <span style="color: #66cd00;">shift</span>;
      $self-&gt;{<span style="color: #ffff00;">accept</span>} ||= $self-&gt;recurring($self-&gt;accept_interval =&gt; \&amp;_accepting);
      $self-&gt;{<span style="color: #ffff00;">stop</span>} ||= $self-&gt;recurring(<span style="color: #ffff00;">1</span> =&gt; \&amp;_stop);
}
</pre>

<p>
     启动了定时的执行_accepting，注意，同一个进程内不会启动多个．
</p>


<pre class="src src-perl"> <span style="color: #00ffff;">sub</span> <span style="color: #4186be;">_accepting</span> {
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$self</span> = <span style="color: #66cd00;">shift</span>;

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Check if we have acceptors</span>
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$acceptors</span> = $self-&gt;{<span style="color: #ffff00;">acceptors</span>} ||= {};
  <span style="color: #00ffff;">return</span> $self-&gt;_remove(<span style="color: #66cd00;">delete</span> $self-&gt;{<span style="color: #ffff00;">accept</span>}) <span style="color: #00ffff;">unless</span> <span style="color: #66cd00;">keys</span> <span style="color: #ff0000; background-color: #eeeed1; font-weight: bold; font-style: italic;">%</span><span style="color: #ffffff; font-weight: bold;">$acceptors</span>;

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Check connection limit</span>
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$i</span>   = <span style="color: #66cd00;">keys</span> %{$self-&gt;{<span style="color: #ffff00;">connections</span>}};
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$max</span> = $self-&gt;max_connections;
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> $i &lt; $max;

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Acquire accept mutex</span>
  <span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$cb</span> = $self-&gt;<span style="color: #ff7f50;">lock</span>) { <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> $self-&gt;$cb(!$i) }
  $self-&gt;_remove(<span style="color: #66cd00;">delete</span> $self-&gt;{<span style="color: #ffff00;">accept</span>});

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Check if multi-accept is desirable</span>
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$multi</span> = $self-&gt;multi_accept;
  $_-&gt;multi_accept($max &lt; $multi ? 1 : $multi)-&gt;start <span style="color: #00ffff;">for</span> <span style="color: #ff7f50;">values</span> <span style="color: #ff0000; background-color: #eeeed1; font-weight: bold; font-style: italic;">%</span><span style="color: #ffffff; font-weight: bold;">$acceptors</span>;
  $self-&gt;{<span style="color: #ffff00;">accepting</span>}++;
}
</pre>

<p>
     此方法每隔一段时间运行一次，目的是注册accept的事件处理，直到成功注册(便会停止尝试)．<br/>&nbsp;什么时候失败呢？
</p><ul>
<li>锁没获取，其它进程的server获取了锁，已经注册了
</li>
<li>链接数达到了最大链接数
</li>
</ul>

<p>     如果获取了锁，则进行注册处理函数，这在Mojo::IOLoop::Server:start方法内进行:
</p>


<pre class="src src-perl"><span style="color: #00ffff;">sub</span> <span style="color: #4186be;">start</span> {
 <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$self</span> = <span style="color: #66cd00;">shift</span>;
 weaken $self;
 $self-&gt;reactor-&gt;io(
   $self-&gt;{<span style="color: #ffff00;">handle</span>} =&gt; <span style="color: #00ffff;">sub</span> { $self-&gt;_accept <span style="color: #00ffff;">for</span> 1 &#65294;&#65294; $self-&gt;multi_accept });
}
</pre>

<p>
     设置server的handle(是socket的fd)的处理函数为_accept方法．multi_accept表示一次可以获取多个可以accept的链接:
</p>


<pre class="src src-perl"><span style="color: #00ffff;">sub</span> <span style="color: #4186be;">_accept</span> {
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$self</span> = <span style="color: #66cd00;">shift</span>;

  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$handle</span> = $self-&gt;{<span style="color: #ffff00;">handle</span>}-&gt;<span style="color: #ff7f50;">accept</span>;
  $handle-&gt;blocking(0);

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Disable Nagle's algorithm</span>
  <span style="color: #ff7f50;">setsockopt</span> $handle&#65292; IPPROTO_TCP&#65292; TCP_NODELAY&#65292; 1;

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Start <span class="caps">TLS</span> handshake</span>
  <span style="color: #00ffff;">return</span> $self-&gt;emit_safe(<span style="color: #ffff00;">accept</span> =&gt; $handle) <span style="color: #00ffff;">unless</span> <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$tls</span> = $self-&gt;{<span style="color: #ffff00;">tls</span>};
  weaken $self;
  $tls-&gt;{<span style="color: #ffff00;">SSL_error_trap</span>} = <span style="color: #00ffff;">sub</span> {
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$handle</span> = <span style="color: #66cd00;">delete</span> $self-&gt;{<span style="color: #ffff00;">handles</span>}{<span style="color: #66cd00;">shift</span>()};
    $self-&gt;reactor-&gt;remove($handle);
    <span style="color: #ff7f50;">close</span> $handle;
  };
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> $handle = <span class="caps">IO</span>::Socket::SSL-&gt;start_SSL($handle&#65292; <span style="color: #ff0000; background-color: #eeeed1; font-weight: bold; font-style: italic;">%</span><span style="color: #ffffff; font-weight: bold;">$tls</span>);
  $self-&gt;reactor-&gt;io($handle =&gt; <span style="color: #00ffff;">sub</span> { $self-&gt;_tls($handle) });
  $self-&gt;{<span style="color: #ffff00;">handles</span>}{$handle} = $handle;
}
</pre>

</div>

</div>

<div id="outline-container-1-2" class="outline-4">
<h4 id="sec-1-2">listen&nbsp;socket上链接达到</h4>
<div class="outline-text-4" id="text-1-2">

<p>     可以看到当Reactor上面的读写发生时候，这个函数被调用，他执行socket的accept获得新的socket(和client链接的socket)．然后触发了accept事件．<br/>
     accept事件是什么时候被注册的呢？<br/>&nbsp;Mojo::IOLoop中server方法:
</p>


<pre class="src src-perl"><span style="color: #00ffff;">sub</span> <span style="color: #4186be;">server</span> {
  <span style="color: #00ffff;">my</span> (<span style="color: #ffffff; font-weight: bold;">$self</span>&#65292; $cb) = (<span style="color: #66cd00;">shift</span>&#65292; <span style="color: #66cd00;">pop</span>);
  $self = $self-&gt;singleton <span style="color: #00ffff;">unless</span> <span style="color: #ff7f50;">ref</span> $self;

  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$server</span> = Mojo::IOLoop::Server-&gt;new;
  weaken $self;
  $server-&gt;on(
    <span style="color: #ffff00;">accept</span> =&gt; <span style="color: #00ffff;">sub</span> {
      <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$handle</span> = <span style="color: #66cd00;">pop</span>;

      <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Turn handle into stream</span>
      <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$stream</span> = Mojo::IOLoop::Stream-&gt;new($handle);
      $self-&gt;$cb($stream&#65292; $self-&gt;stream($stream));

      <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Enforce connection limit (randomize to improve load balancing)</span>
      $self-&gt;max_connections(0)
        <span style="color: #00ffff;">if</span> <span style="color: #66cd00;">defined</span> $self-&gt;{<span style="color: #ffff00;">accepts</span>}
        &amp;&amp; ($self-&gt;{<span style="color: #ffff00;">accepts</span>} -= <span style="color: #ff7f50;">int</span>(<span style="color: #ff7f50;">rand</span> 2) + 1) &lt;= 0;

      <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Stop accepting to release accept mutex</span>
      $self-&gt;_not_accepting;
    }
  );
</pre>

</div>

</div>

<div id="outline-container-1-3" class="outline-4">
<h4 id="sec-1-3">为链接创建Mojo::IOLoop::Stream</h4>
<div class="outline-text-4" id="text-1-3">

<p>     注册了server上面的accept事件，于是这里注册的处理函数被执行，观察到，他创建了一个Mojo::IOLoop::Stream实例，表示Client和Server的这条链接．然后执行了一个callback．<br/>
     这个callback是什么呢？<br/>&nbsp;由于这里的server方法是被Mojo::Server::Daemon的_listen方法调用用来创建acceptor．在那里可以看到提供了此回调:
</p>


<pre class="src src-perl"><span style="color: #00ffff;">sub</span> <span style="color: #4186be;">_listen</span> {
  <span style="color: #00ffff;">my</span> (<span style="color: #ffffff; font-weight: bold;">$self</span>&#65292; $listen) = <span style="color: #0000ff; background-color: #eeeed1; font-weight: bold;">@_</span>;
  &#65294;&#65294;&#65294;
  weaken $self;
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$id</span> = $self-&gt;ioloop-&gt;server(
    $options =&gt; <span style="color: #00ffff;">sub</span> {
      <span style="color: #00ffff;">my</span> (<span style="color: #ffffff; font-weight: bold;">$loop</span>&#65292; $stream&#65292; $id) = <span style="color: #0000ff; background-color: #eeeed1; font-weight: bold;">@_</span>;

      <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$c</span> = $self-&gt;{<span style="color: #ffff00;">connections</span>}{$id} = {<span style="color: #ffff00;">tls</span> =&gt; $tls};
      <span style="color: #ff7f50;">warn</span> <span style="color: #ffff00;">"-- Accept (@{[$stream-&gt;handle-&gt;peerhost]})\n"</span> <span style="color: #00ffff;">if</span> <span class="caps">DEBUG</span>;
      $stream-&gt;timeout($self-&gt;inactivity_timeout);

      $stream-&gt;on(<span style="color: #ffff00;">close</span> =&gt; <span style="color: #00ffff;">sub</span> { $self-&gt;_close($id) });
      $stream-&gt;on(
        <span style="color: #ffff00;">error</span> =&gt; <span style="color: #00ffff;">sub</span> {
          <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> $self;
          $self-&gt;app-&gt;<span style="color: #ff7f50;">log</span>-&gt;error(<span style="color: #66cd00;">pop</span>);
          $self-&gt;_close($id);
        }
      );
      $stream-&gt;on(<span style="color: #ffff00;">read</span> =&gt; <span style="color: #00ffff;">sub</span> { $self-&gt;_read($id =&gt; <span style="color: #66cd00;">pop</span>) });
      $stream-&gt;on(<span style="color: #ffff00;">timeout</span> =&gt;
          <span style="color: #00ffff;">sub</span> { $self-&gt;app-&gt;<span style="color: #ff7f50;">log</span>-&gt;debug(<span style="color: #ffff00;">'Inactivity timeout&#65294;'</span>) <span style="color: #00ffff;">if</span> $c-&gt;{<span style="color: #ffff00;">tx</span>} });
   }
);
&#65294;&#65294;&#65294;
</pre>

</div>

</div>

<div id="outline-container-1-4" class="outline-4">
<h4 id="sec-1-4">client发来数据</h4>
<div class="outline-text-4" id="text-1-4">

<p>   这个回掉注册了stream上面的事件处理:close，error，read，timeout等．read方法，表示链接上有数据达到，即client发来数据:
</p>


<pre class="src src-perl"><span style="color: #00ffff;">sub</span> <span style="color: #4186be;">_read</span> {
  <span style="color: #00ffff;">my</span> (<span style="color: #ffffff; font-weight: bold;">$self</span>&#65292; $id&#65292; $chunk) = <span style="color: #0000ff; background-color: #eeeed1; font-weight: bold;">@_</span>;

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Make sure we have a transaction and parse chunk</span>
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$c</span> = $self-&gt;{<span style="color: #ffff00;">connections</span>}{$id};
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$tx</span> = $c-&gt;{<span style="color: #ffff00;">tx</span>} ||= $self-&gt;_build_tx($id&#65292; $c);
  <span style="color: #ff7f50;">warn</span> <span style="color: #ffff00;">"-- Server &lt;&lt;&lt; Client (@{[$tx-&gt;req-&gt;url-&gt;to_abs]})\n$chunk\n"</span> <span style="color: #00ffff;">if</span> <span class="caps">DEBUG</span>;
  $tx-&gt;server_read($chunk);

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Last keep-alive request or corrupted connection</span>
  $tx-&gt;res-&gt;headers-&gt;connection(<span style="color: #ffff00;">'close'</span>)
    <span style="color: #00ffff;">if</span> (($c-&gt;{<span style="color: #ffff00;">requests</span>} || 0) &gt;= $self-&gt;max_requests) || $tx-&gt;req-&gt;error;

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Finish or start writing</span>
  <span style="color: #00ffff;">if</span> ($tx-&gt;is_finished) { $self-&gt;_finish($id&#65292; $tx) }
  <span style="color: #00ffff;">elsif</span> ($tx-&gt;is_writing) { $self-&gt;_write($id) }
}
</pre>

</div>

</div>

<div id="outline-container-1-5" class="outline-4">
<h4 id="sec-1-5">transaction被创建并处理数据</h4>
<div class="outline-text-4" id="text-1-5">

<p>   此方法创建transaction(如果链接上有tx就复用)，注意调次方法被调用的时候数据已经就绪了，在$chunk中<br/>&nbsp;调用transacton上面的server_read方法，这个方法并不会从socket读数据(因为数据已经读上来，在$chunk中)，而是进行分析数据:
</p>


<pre class="src src-perl"><span style="color: #ff0000;"># </span><span style="color: #ff0000;">Mojo::Transaction::<span class="caps">HTTP</span></span>
<span style="color: #00ffff;">sub</span> <span style="color: #4186be;">server_read</span> {
  <span style="color: #00ffff;">my</span> (<span style="color: #ffffff; font-weight: bold;">$self</span>&#65292; $chunk) = <span style="color: #0000ff; background-color: #eeeed1; font-weight: bold;">@_</span>;

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Parse request</span>
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$req</span> = $self-&gt;req;
  $req-&gt;parse($chunk) <span style="color: #00ffff;">unless</span> $req-&gt;error;
  $self-&gt;{<span style="color: #ffff00;">state</span>} ||= <span style="color: #ffff00;">'read'</span>;

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Generate response</span>
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> $req-&gt;is_finished &amp;&amp; !$self-&gt;{<span style="color: #ffff00;">handled</span>}++;
  $self-&gt;emit(<span style="color: #ffff00;">upgrade</span> =&gt; Mojo::Transaction::WebSocket-&gt;new(<span style="color: #ffff00;">handshake</span> =&gt; $self))
    <span style="color: #00ffff;">if</span> <span style="color: #ff7f50;">lc</span>($req-&gt;headers-&gt;upgrade // <span style="color: #ffff00;">''</span>) <span style="color: #ff7f50;">eq</span> <span style="color: #ffff00;">'websocket'</span>;
  $self-&gt;emit(<span style="color: #ffff00;">'request'</span>);
}
</pre>

<p>
     此方法调用$req-&gt;parse方法分析数据，先分析<span class="caps">HTTP</span>头，然后使用Mojo::Content分析headers和body，如果完整那么一次就可以分析完，状态变为finished，
     于是本函数的最后一行被调用，触发request事件．<br/>
     事件处理函数是？<br/>&nbsp;由于tx是在Mojo::Daemon::_read方法内调用_build_tx构建:
</p>


<pre class="src src-perl"><span style="color: #00ffff;">sub</span> <span style="color: #4186be;">_build_tx</span> {
  <span style="color: #00ffff;">my</span> (<span style="color: #ffffff; font-weight: bold;">$self</span>&#65292; $id&#65292; $c) = <span style="color: #0000ff; background-color: #eeeed1; font-weight: bold;">@_</span>;

  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$tx</span> = $self-&gt;build_tx-&gt;connection($id);
  $tx-&gt;res-&gt;headers-&gt;server(<span style="color: #ffff00;">'Mojolicious (Perl)'</span>);
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$handle</span> = $self-&gt;ioloop-&gt;stream($id)-&gt;handle;
  $tx-&gt;local_address($handle-&gt;sockhost)-&gt;local_port($handle-&gt;sockport);
  $tx-&gt;remote_address($handle-&gt;peerhost)-&gt;remote_port($handle-&gt;peerport);
  $tx-&gt;req-&gt;url-&gt;base-&gt;scheme(<span style="color: #ffff00;">'https'</span>) <span style="color: #00ffff;">if</span> $c-&gt;{<span style="color: #ffff00;">tls</span>};

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Handle upgrades and requests</span>
  weaken $self;
  $tx-&gt;on(
    <span style="color: #ffff00;">upgrade</span> =&gt; <span style="color: #00ffff;">sub</span> {
      <span style="color: #00ffff;">my</span> (<span style="color: #ffffff; font-weight: bold;">$tx</span>&#65292; $ws) = <span style="color: #0000ff; background-color: #eeeed1; font-weight: bold;">@_</span>;
      $ws-&gt;server_handshake;
      $self-&gt;{<span style="color: #ffff00;">connections</span>}{$id}{<span style="color: #ffff00;">ws</span>} = $ws;
    }
  );
  $tx-&gt;on(
    <span style="color: #ffff00;">request</span> =&gt; <span style="color: #00ffff;">sub</span> {
      <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$tx</span> = <span style="color: #66cd00;">shift</span>;
      $self-&gt;emit(<span style="color: #ffff00;">request</span> =&gt; $self-&gt;{<span style="color: #ffff00;">connections</span>}{$id}{<span style="color: #ffff00;">ws</span>} || $tx);
      $tx-&gt;on(<span style="color: #ffff00;">resume</span> =&gt; <span style="color: #00ffff;">sub</span> { $self-&gt;_write($id) });
    }
  );

  <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Kept alive if we have more than one request on the connection</span>
  <span style="color: #00ffff;">return</span> ++$c-&gt;{<span style="color: #ffff00;">requests</span>} &gt; 1 ? $tx-&gt;kept_alive(1) : $tx;
}
</pre>

</div>

</div>

<div id="outline-container-1-6" class="outline-4">
<h4 id="sec-1-6">数据分析完整触发tx上的request事件</h4>
<div class="outline-text-4" id="text-1-6">

<p>     request事件的处理函数会执行Mojo::Server::Daemon实例上注册的request处理函数，传递tx作为参数:
</p>


<pre class="src src-perl"><span style="color: #ff0000;"># </span><span style="color: #ff0000;">Mojo::Server</span>
<span style="color: #00ffff;">sub</span> <span style="color: #4186be;">new</span> {
  <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$self</span> = <span style="color: #66cd00;">shift</span>-&gt;<span class="caps">SUPER</span>::new(<span style="color: #0000ff; background-color: #eeeed1; font-weight: bold;">@_</span>);
  $self-&gt;on(<span style="color: #ffff00;">request</span> =&gt; <span style="color: #00ffff;">sub</span> { <span style="color: #66cd00;">shift</span>-&gt;app-&gt;handler(<span style="color: #66cd00;">shift</span>) });
  <span style="color: #00ffff;">return</span> $self;
}
</pre>

<p>
     可以看到这里会调用app上面的handler函数:
</p></div>

</div>

<div id="outline-container-1-7" class="outline-4">
<h4 id="sec-1-7">执行app上的handler方法</h4>
<div class="outline-text-4" id="text-1-7">

<p>   handler方法在Mojolicious．pm中，handler方法目的是生成response(响应内容):
</p><ul>
<li>redirect
</li>
<li>static&nbsp;资源
</li>
<li>route到app自定义的controller
</li>
</ul>

<p>   在生成response，且如果需要渲染模板而渲染后，执行rendered方法，次方法是收尾工作，在次方法的最后执行:
</p>


<pre class="src src-perl"><span style="color: #00ffff;">sub</span> <span style="color: #4186be;">rendered</span> {
    &#65294;&#65294;&#65294;
    $self-&gt;tx-&gt;resume;
    <span style="color: #00ffff;">return</span> $self;
}
</pre>

<p>
   唤醒了tx:
</p></div>

</div>

<div id="outline-container-1-8" class="outline-4">
<h4 id="sec-1-8">tx被唤醒写response数据到链接</h4>
<div class="outline-text-4" id="text-1-8">

<p>   在Mojo::Server::Daemon::_build_tx内:
</p>


<pre class="src src-perl">$tx-&gt;on(<span style="color: #ffff00;">resume</span> =&gt; <span style="color: #00ffff;">sub</span> { $self-&gt;_write($id) });
</pre>

<p>
   可以看到Mojo::Server::Daemon的_write方法被执行:
</p>


<pre class="src src-perl"><span style="color: #00ffff;">sub</span> <span style="color: #4186be;">_write</span> {
    <span style="color: #00ffff;">my</span> (<span style="color: #ffffff; font-weight: bold;">$self</span>&#65292; $id) = <span style="color: #0000ff; background-color: #eeeed1; font-weight: bold;">@_</span>;

    <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Not writing</span>
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$c</span>  = $self-&gt;{<span style="color: #ffff00;">connections</span>}{$id};
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$tx</span> = $c-&gt;{<span style="color: #ffff00;">tx</span>};
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> $tx-&gt;is_writing;

    <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Get chunk and write</span>
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">if</span> $c-&gt;{<span style="color: #ffff00;">writing</span>}++;
    <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$chunk</span> = $tx-&gt;server_write;
    <span style="color: #66cd00;">delete</span> $c-&gt;{<span style="color: #ffff00;">writing</span>};
    <span style="color: #ff7f50;">warn</span> <span style="color: #ffff00;">"-- Server &gt;&gt;&gt; Client (@{[$tx-&gt;req-&gt;url-&gt;to_abs]})\n$chunk\n"</span> <span style="color: #00ffff;">if</span> <span class="caps">DEBUG</span>;
    <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$stream</span> = $self-&gt;ioloop-&gt;stream($id)-&gt;<span style="color: #ff7f50;">write</span>($chunk);

    <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Finish or continue writing</span>
    weaken $self;
    <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$cb</span> = <span style="color: #00ffff;">sub</span> { $self-&gt;_write($id) };
    <span style="color: #00ffff;">if</span> ($tx-&gt;is_finished) {
      <span style="color: #00ffff;">if</span> ($tx-&gt;has_subscribers(<span style="color: #ffff00;">'finish'</span>)) {
        $cb = <span style="color: #00ffff;">sub</span> { $self-&gt;_finish($id&#65292; $tx) }
      }
      <span style="color: #00ffff;">else</span> {
        $self-&gt;_finish($id&#65292; $tx);
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">unless</span> $c-&gt;{<span style="color: #ffff00;">tx</span>};
      }
    }
    $stream-&gt;<span style="color: #ff7f50;">write</span>(<span style="color: #ffff00;">''</span>&#65292; $cb);
  }
</pre>

<p>
   此方法的目的是写response给客户端，调用tx-&gt;server_write获得要写的数据，然后在connection绑定的Mojo::IOLoop::Stream实例上面调用write方法写出数据．&nbsp;如果tx数据完整则状态为finished，调用Mojo::Server::Daemon的_finish方法，结束tx:
</p></div>

</div>

<div id="outline-container-1-9" class="outline-4">
<h4 id="sec-1-9">结束tx</h4>
<div class="outline-text-4" id="text-1-9">




<pre class="src src-perl"><span style="color: #00ffff;">sub</span> <span style="color: #4186be;">_finish</span> {
    <span style="color: #00ffff;">my</span> (<span style="color: #ffffff; font-weight: bold;">$self</span>&#65292; $id&#65292; $tx) = <span style="color: #0000ff; background-color: #eeeed1; font-weight: bold;">@_</span>;

    <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Always remove connection for WebSockets</span>
    <span style="color: #00ffff;">return</span> $self-&gt;_remove($id) <span style="color: #00ffff;">if</span> $tx-&gt;is_websocket;

    <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Finish transaction</span>
    $tx-&gt;server_close;
    &#65294;&#65294;&#65294;
    <span style="color: #ff0000;"># </span><span style="color: #ff0000;">Close connection if necessary</span>
    <span style="color: #00ffff;">my</span> <span style="color: #ffffff; font-weight: bold;">$req</span> = $tx-&gt;req;
   <span style="color: #00ffff;">return</span> $self-&gt;_remove($id) <span style="color: #00ffff;">if</span> $req-&gt;error || !$tx-&gt;keep_alive;
</pre>

<p>
   从这里可以看出tx被设置为finished，如果非keepalive链接，还会关闭链接(同时删除了tx，tx属于connection)．
</p>
<p>
至此请求处理完成
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2">总结</h3>
<div class="outline-text-3" id="text-2">

<ul>
<li>一个client链接代表一个connection
</li>
<li>一个connection对应一个Mojo::IOLoop::Stream
</li>
<li>一个connection上面有一个tx
</li>
<li>tx完成请求的分析，转交app处理，响应生成
</li>
<li>Stream负责将链接上数据读取和写入
</li>
<li>connection被注册在listen&nbsp;socket上的回调创建，进而stream被创建
</li>
<li>tx被stream上read事件触发创建(可能复用)
</li>
<li>每个listen&nbsp;socket上面一个Mojo::IOLoop::Server实例，对应于一个acceptor
</li>
<li>keepalive的连接请求完成后不会删除tx和connection，tx被标记为finished
</li>
</ul>


</div>
</div>

      </div>
      <!-- Table of Content-->
      <script src="http://code.jquery.com/jquery-1.9.0.min.js" charset="utf-8"></script>
      <script src="/js/jquery.tableofcontents.min.js" charset="utf-8"></script>
      <script charset="utf-8">
        $(function(){
          $("#toc>ol").tableOfContents(
           null,
           {
             startLevel: 3,
             depth:3,
             topLinks: "\u21E7",
             topLinkClass: "toc-top-link",
           topBodyId: "toc-top",
          });
        });
        
      </script>
      <!-- Google Plus--><br>
      <!-- Place this tag where you want the +1 button to render.-->
      <div data-size="medium" class="g-plusone"></div>
      <!--google plus-->
      <!-- Place this tag after the last +1 button tag.-->
      <script>
        window.___gcfg = {lang: 'zh-CN'};
        
        (function() {
          var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
          po.src = 'https://apis.google.com/js/plusone.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
        
        
      </script>
      <!-- DISQUS-->
      <div id="disqus_thread" style="padding-top:1em"></div>
      <script>
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'chinaxing'; // required: replace example with your forum shortname
        
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
        
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript><a id="dsq-brlink" href="http://disqus.com">comments powered by<span class="logo-disqus">Disqus</span></a>
    </section>
    <footer>
    </footer>
  </body>
  <!-- google Analytics-->
  <script>
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37422195-1']);
    _gaq.push(['_trackPageview']);
    
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <!-- clusterMaps-->
  <script>
    var _clustrmaps = {
     'url' : 'http://chinaxing.org', 
     'user' : 1103575, 
     'server' : '2',
     'id' : 'clustrmaps-widget', 
      'version' : 1, 
     'date' : '2013-07-14',
     'lang' : 'zh',
     'corners' : 'square' 
    };
    (function (){
      var s = document.createElement('script'); 
      s.type = 'text/javascript'; 
      s.async = true; 
      s.src = 'http://www2.clustrmaps.com/counter/map.js'; 
      var x = document.getElementsByTagName('script')[0]; 
      x.parentNode.insertBefore(s, x);})();
  </script>
  <noscript>
    a(href="http://www2.clustrmaps.com/user/f0710d6d7")
      img(src="http://www2.clustrmaps.com/stats/maps-no_clusters/chinaxing.org-thumb.jpg", alt="Locations of visitors to this page")
  </noscript>
</html>