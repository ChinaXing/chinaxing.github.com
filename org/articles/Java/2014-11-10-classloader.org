#+BEGIN_HTML
---
date: 2014-11-10 20:49:01
template: tech.jade
title: ClassLoader
category: Java
chage_frequency: monthly
tag: java,classloader
---
#+END_HTML
#+OPTIONS: toc:nil
#+TOC: headlines 2
*** ClassLoader
Java 将ClassLoader开放给程序开发者，可以区别于静态语言的一个优势就是可以对类加载进行控制（编程），这是非常灵活和可扩展的一个点。

ClassLoader提供的可自定义特点，给应用开发者带来方便，将资源查找抽象出来。

利用了ClassLoader机制的项目如OSGI、Tomcat等实现同一JVM内部应用隔离，带来的好处是可以一个JVM里面部署多个模块互不影响。

*** Class
java中，每个Class对象（java.lang.Class）代表了一个类，Class对象被某个ClassLoader加载（getClassLoader）。一个类的标识如下：
#+BEGIN_QUOTE
package + class + classLoaderId 
#+END_QUOTE
因此，虽然是同一类文件，被不同的ClassLoader加载，那么他们就不是同一个Class对象，不是同一个类。如果相互引用，JVM会报类型错。

*** ClassLoader分类
ClassLoader按照启动顺序或者所处角色（使命）可以分为3类：
- bootstrap ClassLoader :: 是系统的第一个ClassLoader，用C++实现，用来在初始阶段加载类（包括加载ClassLoader.class和Class.class）
- extend ClassLoader :: 是Jvm启动初始化完成后用来加载扩展的ClassLoader，扩展位于${JAVA\_HOME}/lib/ext/目录下面
- System ClassLoader :: 加载用户指定的classpath下类的ClassLoader。也称作AppClassLoader

上面三个ClassLoader，第一个比较特殊外，其余的都是ClassLoader.class的子类。都是Java语言编写的，而且都继承于URLClassLoader

*** ClassLoader 继承
ClassLoader 在逻辑上被组织为一个 *父-子* 关系，即：每个ClassLoader有个parent。extend ClassLoader的父ClassLoader是bootstrap ClassLoader，但是因为bootstrap ClassLoader并非一个ClassLoader.class对象，extendClassLoader.parent 为null。

因此，无法拿到bootstrapClassLoader的引用。

除了这一点异常外，每个ClassLoader总有一个parent。关系如下图：
#+BEGIN_SRC dot :file ~/ChinaXing.org/org/img/classLoader-toplogy.png :cmdline -Kdot -Tpng :eval no-export
digraph cl_top {
  node [ fontsize = 10 style = point ]
  edge [ color = red , fontcolor = gray fontsize = 8]

  bootstrapClassLoader [ fontcolor = red ]
  extClassLoader [ fontcolor = blue ]

  extClassLoader -> bootstrapClassLoader [ label = "parent" style = dashed ]
  app1ClassLoader -> extClassLoader [ label = "parent" ]
  app0ClassLoader -> extClassLoader [ label = "parent" comment = ".parent" ]

  {rank = same; app0ClassLoader app1ClassLoader} 
  rankdir = BT
  label = "ClassLoader 继承关系"
  fontsize = 8
}
#+END_SRC

#+RESULTS:
[[file:/img/classLoader-toplogy.png]]

*** 类查找策略
ClassLoader的主要作用就是加载类（还可以加载resource），加载类的时候，调用loadClass方法，加载类的时候，按照如下的策略：
1. 如果本ClassLoader已经加载过此类，直接返回Class对象
2. 委托给parent ClassLoader 查找，如果找到返回
3. 调用本ClassLoader的findClass进行查找，查找到后记录到本ClassLoader加载类列表

其中, 记录到已加载类集合的操作是JVM完成的（调用addClass）

通过这个顺序，可以保证：
1. 一个类不会被重复加载
2. 一个类如果parent ClassLoader已经加载，child ClassLoader 无法覆盖
3. 同级的（sibling）ClassLoader加载的类不会互相影响（不可见）。

在这个基础上可以保证安全性、隔离性。

*** 类加载过程
#+BEGIN_SRC dot :file ~/ChinaXing.org/org/img/classload_procedure.png :cmdline -Tpng -Kdot :eval no-export
digraph load_class_procedure {
  node [ color = red style = dashed fontsize = 10 ]
  edge [ color = blue fontsize = 8 ]
  rankdir = LR
  parent_loadClass [ label = "parent.loadClass" ]
  return [ shape = diamond ]
  loadClass -> findLoadedClass
  findLoadedClass -> parent_loadClass [ label = "N" ]
  findLoadedClass -> return [ label = "Y" ]
  parent_loadClass -> findClass [ label = "N" ]
  parent_loadClass -> return [ label = "Y" ]
  findClass -> defineClass 
  defineClass -> findClass 
  findClass -> return 
  { rank = same ; loadClass findLoadedClass parent_loadClass findClass }

  label = "类加载流程"
  fontsize = 8
}
#+END_SRC

#+RESULTS:
[[file:/img/classload_procedure.png]]

其中ClassLoader种的findClass方法是一个未被实现的方法:
#+BEGIN_SRC java 
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
#+END_SRC
对于ClassLoader的实现者，只要实现此方法，将类的字节码读入byte[]，然后调用ClassLoader提供的defineClass方法即可生成出class对象。

可见，类定义的关键是实现根据类名找到类字节码。

**** defineClass 
defineClass的目标很简单，就是通过字节码将Class对象创建出来，下面是流程图：
#+BEGIN_SRC dot :file ~/ChinaXing.org/org/img/classloader-defineClass.png :cmdline -Kdot -Tpng :eval no-export
digraph defineClass {
  node [ color = red style = dashed fontsize = 10 ]
  edge [ color = blue fontsize = 8 ]
  0 [ label = "defineClass" ]
  1 [ label = "defineClass0" ]
  2 [ label = "defineClass1" ]
  3 [ label = "defineClass2" ]
  4 [ label = "defineTransformedClass" ] 
  5 [ label = "classFileTransformer(s)" ]
  0 -> { 1,2,3 }
  
  2 -> 4 [ label = "formatError" fontcolor = red ]
  3 -> 4 [ label = "formatError"  fontcolor = red ]
  4 -> 5 [ label = "transform" ]
  5 -> 2 
  {rank = same ; 1 2 3 }

  label = "类定义过程"
  fontsize = 8
}
#+END_SRC

#+RESULTS:
[[file:/img/classloader-defineClass.png]]

其中，
- defineClass0 :: 用于定义没有源文件的类（动态生成代码）
- defineClass1 :: 用于从byte[] 定义类
- defineClass2 :: 用于从ByteBuffer 定义类
- defineTransformedClass :: 通过调用注册的ClassFileTransform链条，对字节码进行变换，然后再执行defineClass1进行尝试

*** URLClassLoader
URLClassLoader是 默认提供的CLassLoader的实现，也被JVM用作默认的类加载器，它可以从一簇URL中加载类字节码。

URL可以是:
- 指向class文件 :: 一个指向class文件的url
- 指向jar包 :: 一个包含了class文件的jar包

因此我们可以把jar包或者class文件放入classpath。

但是要注意的是，URLClassLoader并不能识别jar包中的jar，它只能识别jar包中的class 文件，因此，企图让java加载jar包中jar中的类是不支持的。
必须自己实现ClassLoader（可以参考OneJar项目）

还要注意的一点是，对于通过 /-jar/ 参数指定jar包运行的方式，命令行设置的classpath（-cp选项）被忽略，只能通过jar包中MANIFEST.MF中得Class-path属性设置。

这里的潜在含义是，jar包作为一个完整的整体，是不需要（不应该）依赖外部类（除jvm本身）而可以独立运行的。

*** 安全性
对于定义classLoader，java security有一个permission控制是否有权限进行ClassLoader的创建: /checkCreateClassLoader/ 

每个class还会关联一个ProtectDomain，定义了一个Domain，并赋予相应的权限。

定义类的时候，JVM还会检查调用者是否有对对应package的权限，如果没有也不能创建类。

此外还可以通过签名验证来保证更强的安全性（未深入了解）。

*** 类加载和类链接
loadClass 完成类的加载，具体来说就是根据类名找到类字节码，然后返回一个Class对象代表这个类。

此时的类，JVM并没有做深入的剖析，如分析继承和依赖等。

对类进行深度解析的过程叫做类链接，link，发生在load之后，类被真实实例化之前。

在loadClass的调用中，有一个选项可以指定是否在类加载完成后进行一下link。

类的link涉及到对类内部的分析，对于一些依赖要进行关联加载，保证接下来的实例化可以进行。

如果没有让loadClass进行link类，那么类的link发生在代码运行中类被使用的时候（这里不一定是执行到某一处）。

比如，一个类A被使用，那么在链接的时候，会触发他的所有父类、接口的的链接（如果没有加载要加载）。

关于这个过程，还没有深入、系统的了解。
*** Reference
- JDK ClassLoader.java
- JDK URLClassLoader.java
- [[http://one-jar.sourceforge.net][OneJar project]]
