#+BEGIN_HTML
---
date: 2015-09-26 23:23:59
template: tech.jade
title: FastJson 使用 ASM反序列化
category: Java
chage_frequency: monthly
tag: Java,json,asm
---
#+END_HTML
#+OPTIONS: toc:nil
#+TOC: headlines 2

通过调查了市面上的几个Json库和Java序列化工具，包括Hession、Gson等，发现多数还是使用反射的机制进行反序列化和序列化，大概是因为Gson不对性能苛刻，如果苛刻可以使用Protobuf等更加高效的工具，

此外，msgpack也表现不错，不过似乎是不太好用，用户接口不好。

与之不同的是FastJson。

FastJson 的反序列化使用了ASM库，好处是避免了反射的频繁调用。

FastJson初始化时候先将各种默认类别的Deserializer进行注册。

当需要反序列化一个JavaBean对象时，使用ASM的反序列化工厂生成一个针对此类型Type的反序列化器，并做缓冲，这样下次就不需要在生成，可以直接使用。

反序列化工厂首先会通过反射拿到这个Type的所有Field、setter、constructor等要素，为以后服务。

下面说明下利用ASM对类型T进行反序列化器生成的过程：

1. 使用asm创建一个继承ASMDeserializer的类——A。
2. 为T的每一个Field在A中生成一个ObjectDeserializer的Field，名称是："FiledName+_deser", 这是为了在反序列化的时候，快速拿到Field的反序列化器，进行反序列化。
3. 为T的每一个Field在A中生成一个Json Key的描述字符串，这是为了JSONLexer能够根据此名字找到对应的Json key。
4. 生成生成反序列化对象的代码——根据传入的类型Type生成一个Instance，是反序列化完成后要返回的对象。
4. 生成反序列化的代码——这段代码完成反序列化。
   
下面重点说明下反序列化的逻辑：
1. 创建Instance
2. 根据Filed列表，在stack上面为每个Field分配局部变量，名字是{FiledName}_asm，并初始化。
3. 根据Field列表，进行逐个反序列化，每完成一个设置到上一步的对应局部变量里面。
4. 根据局部变量，和第一部创建的Instance，通过调用Instance的setter方法，将Field进行设置进去。
5. 返回Instance

对于普通primitive类型，string类型等一些类型，直接进行反序列化读取设置。而对于对象类型，就需要调用Field上面的deserializer来进行反序列化。
   
通过分析这个过程，得到的性能提升是：
1. 通过缓存类型的反序列化器，避免重复创建反序列化器或者说进行反射调用。节约了时间。
2. 通过ASM进行反序列化器类的生成，好处是可以字节码直接对进行反序列化对象的Field设置，否则就要进行反射的方式来进行对返回对象的方法调用或者Field设置的方式来进行。
3. 经过上面的2步，每个类仅仅进行了一次的反射查询，之后的过程都没有这个反射查询，所以是非常高效的。
   
存在的问题：

通过缓存的方式固然是节省了调用，但是会导致系统中的Class增多，每一个要进行序列化的类型都会有一份对应的反序列化类产生，这可能会导致系统Perm区增长（如果没有设置Perm回收的话）而导致OOM。


序列化的性能和效率的思考：

序列化的2个指标：速度和数据量，对于后端应用，数据传输通常在局域网（机房）,带宽和延迟都是非常理想的情况，可以不再在意序列化后数据量的大小，而关注于序列化的速度。

这时，像json这种对人比较友好而且有工具广泛支持的序列化方式就是不错的选择。

数据采用紧凑的方式进行编码，可以减少parser的处理时间，但是若采用复杂的编码算法，反而增加了parser的计算量，不太好。即，保持数据的量少，但是解析尽量方便。

关于Java的反射：

Java的反射也有缓存，即如果类没有被redefine，那么就一直使用上次反射的缓存。

每次redefine一个类，JVM就会增加Class对象的redefinedCount，反射调用通过这个值来判断类是否被重新定义过了，然后失效缓存。

从这点上来看，其实多次调用反射方法和一次调用的差别不是很大。

查询反射方法和反射Field，走的是native方法。

执行反射方法的调用和反射Field的设置读取，走的是Unsafe接口。

其实，性能都应该不赖。

那么fastjson的做法，快在哪儿？应该是指令少了。
