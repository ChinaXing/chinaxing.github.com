#+begin_html
---
date: 2013-06-23
template: tech.jade
title: DBIx::Class 杂记
category: Perl
change_frequency: monthly
---
#+end_html

使用用[[http://search.cpan.org/perldoc?DBIx%3A%3AClass][DBIx::Class]] (又称为DBIC)做ORM一段时间，这里做些备忘。

** 基本概念
*** Schema
    Schema 可以看做是一个数据库或者一个表空间的代称。
    - schema上注册了ResultSource，可以通过schema->sources得到所有的resultsource name。
    - schema->connect 连接到数据库，返回一个实例化的schema对象
    - schema loadnamespace/loadclass 加载namespace内的所有resultsource和resultset模块
*** ResultSource
    可以看做是一个数据来源，每个resultsource实例代表一行的查询结果，注意dbix-class的定义中这个数据源可以不仅仅是Table。
*** ResultSet
    可以看做是一个查询的结果集合，但是它实际上是一个未被执行的SQL。一旦被执行，结果将是resultsource(s)而不再是resultset，resultset上可以再进行查询，生成新的resultset。
*** ResultClass
    表示resultsource所对应的类，比如'CD'这个resultsource名，对应的resultclass可能为 =MySchema::ResultSource::CD=
*** Storage
    存储后端，是一个DBix::Class::Storage名字空间的类，负责和数据库进行结合，连接、执行SQL（事务）并返回结果等。
*** Namespace
    命名空间是Schema进行加载resultsource和resultset的模块命名空间，通常如果不做明确的指定，就是当前schema所在的命名空间。
*** Relationship
    表示了关系数据库列数据之间的引用关系，不仅仅是外键，而有更加丰富和高级的功能，比如可以进行数据库不支持的关联动作和查询。
    - one to one -- 一一对应： 一个人有一个身份信息
    - many to one -- 多对一：多个行星属于一个恒星的卫星
    - many to many -- 多对多：一个人有多个就读学校，每个学校有多个就读学生
    - maybe -- 可能有：一个人可能有一个情人（也可能没有）

    relationship 也是可以扩展的。
*** deploy
    从schema转换生成SQL语句文件，然后在数据上执行这些SQL
*** load
    从数据库生成Schema，resultsource类
*** version
    schema 的版本，定义在MySchema.pm中VERSION=xxx
** 常用技巧 
*** 向数据库批量插入数据
    使用[[http://search.cpan.org/~ribasushi/DBIx-Class-0.08250/lib/DBIx/Class/Schema.pm#populate][populate]]
    #+BEGIN_SRC perl :eval no
      $schema->populate( 'CD' =>
         [ [qw/Artist Title price/],
           [qw/Sara  'scarborough fair' 25.5/],
           [qw/Mozart 'Serenade for Strings in G major' 20/]
         ]);
    #+END_SRC
*** 自定义storage类型
    在自定义的Schema类内部:
    #+BEGIN_SRC perl :eval no
    __PACKAGE__->storage_type('DBIx::Class::Storage::DBI')
    #+END_SRC
*** 异常hook
    #+BEGIN_SRC perl :eval no
    __PACKAGE__->exception_action( sub { ... } );
    # or
    $schema_obj->exception_action( sub { ... } );
    #+END_SRC
    在处理后需要最后重新throw out异常
*** 异常时打印堆栈
    #+BEGIN_SRC perl :eval no
    $schema_obj->stacktrace(1);
    # or
    $ENV{DBIC_TRACE} = 1;
    #+END_SRC
*** 抛出异常
    DBIC抛出异常使用DBIx::Class::Exception类
*** 解冻和冷冻对象
    #+BEGIN_SRC perl :eval no
    $schema_obj->thaw($obj);
    $schema_obj->freeze($obj);
    #+END_SRC
*** 数据库连接建立
    schema调用storage来根据connection-info中提供的dsn和参数进行连接，连接通过DBI模块进行建立，之后，Storage根据driver的类型（比如Pg）重载storage为:DBIx::Class::Storage::DBI::Pg。
*** 连接的保持
    连接是按需建立，即在第一次需要使用的时候（如执行query）建立，每次执行SQL，都会判断连接的active与否，如果断开则会重新建立连接。\\
    对于父子进程的情况，如果子进程fork出来后，子进程会检查这个连接是否是自己的（检查pid是否与自己一致），如果不一致，则子进程会重新创建一条自己的连接。
*** cursor
    DBIC有cursor的概念，我们可以reset cursor，浏览cursor，而不用进行重复的查询。
*** 查询的执行
    查询在resultset中进行一些调整和组装后，交由storage进行执行。所以几乎查询和事务都是在storage中完成。通过resultsource可以方便的找到对应的storage，而这个storage是schema设定的。一个schema对应一个storage。

    查询语句的构建和转换是在DBIx::Class::Storage::DBI中进行，转换使用DBIx::Class::SQLMaker,该类是对SQL::Abstract的扩展和增强。
*** dbicadmin
    这个类提供一个工具=dbicadmin=。\\
    这个类不是DBIC的核心部分，它只是一个辅助工具。可以完成：
    - Schema部署到数据库 -- deploy
    - 生成Schema对应的SQL语句 -- create
    - 进行升级（如果Schema支持版本） -- upgrade
    - 生成SQL的diff文件 -- create
    - 在库上执行CRUD 操作 -- insert, select, update, delete

** DBIC代码
   DBIC代码有如下特点：
   1. 代码庞大，臃肿，风格糟糕，不清新，不优雅
   2. 使用比较底层的Class::C3类模块进行辅助性构建（加载component，mix对象），使得对象不清晰，错综复杂，底层技术使得代码阅读起来晦涩。\\
      原因猜测是Class::C3模块是作者所写，作者对perl老式的编程方式比较熟悉，开发人员应该是比较老派的Perl程序员。
   3. Result,ResultSet,ResultSource,Storge等基本概念比较清晰，关联关系也容易找到。
=未完待续=

    

    
