#+begin_html
---
date: 2013-06-12
template: tech.jade
title: Mojolicious Web框架实现分析 -- App启动过程
category: Perl
change_frequency: monthly
---
#+end_html
#+OPTIONS: toc:nil
#+TOC: headlines 2
** 前言
   由于我对Web框架的理解不是很清晰，所以希望能借着阅读代码进行全面的了解，加之自己对Perl相对熟悉，所以就选择Perl的web框架来分析，Mojolicious特点是实时，基于事件，
比较拟合当前的趋势，加之其代码精简，也可以从中学习到Perl编程的一些经验和技巧.

由于Mojolicious.pm 是编写App时候继承的类，所以我们从这里开始，分析流程是从程序被启动到一个请求被处理完毕，只会分析HTTP协议.

假设我们编写了MyApp，目录结构如下:
#+BEGIN_SRC sh :eval no-export :results output raw :exports results
tree ~/tmp/my_app 
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
/home/chinaxing/tmp/my_app
├── lib
│   ├── MyApp
│   │   └── Example.pm
│   └── MyApp.pm
├── log
├── public
│   └── index.html
├── script
│   └── my_app
├── t
│   └── basic.t
└── templates
    ├── example
    │   └── welcome.html.ep
    └── layouts
        └── default.html.ep
#+END_EXAMPLE


** 启动Mojolicious App

*** 通过 script/my\_app daemon 启动应用
    #+BEGIN_SRC perl :eval no
    #!/usr/bin/env perl
    
    use strict;
    use warnings;
    
    use FindBin;
    BEGIN { unshift @INC， "$FindBin::Bin/../lib" }
    
    # Start command line interface for application
    require Mojolicious::Commands;
    Mojolicious::Commands->start_app('MyApp');
    #+END_SRC
*** 执行Mojolicious::Commands，此Commands再启动MyApp
   #+BEGIN_SRC perl :eval no
    sub start_app {
      my $self = shift;
      return Mojo::Server->new->build_app(shift)->start(@_);
    }
   #+END_SRC
*** 创建Mojo::Server实例，加载App，启动App
    #+BEGIN_SRC perl :eval no
    sub build_app {
      my ($self， $app) = @_;
      local $ENV{MOJO_EXE};
      return $app->new unless my $e = Mojo::Loader->new->load($app);
      die ref $e ? $e : qq{Couldn't find application class "$app".\n};
    }
    #+END_SRC
   - 使用Mojo::Loader模块加载器加载App，然后调用$app->new来实例化一个App类:
      #+BEGIN_SRC perl :eval no 
      package MyApp;
      use Mojo::Base 'Mojolicious';
  
      # This method will run once at server start
      sub startup {
        my $self = shift;
  
        # Documentation browser under "/perldoc"
        $self->plugin('PODRenderer');
  
        # Router
        my $r = $self->routes;
  
       # Normal route to controller
        $r->get('/')->to('example#welcome');
      }
  
     1;
     #+END_SRC
    从MyApp代码可以看出，集成了Mojolicious类，所以此处的new方法是调用了父类的方法创建了一个实例.
*** App创建完毕，调用其start方法
    mojolicious.pm中
    #+BEGIN_SRC perl :eval no
    has commands => sub {
       my $commands = Mojolicious::Commands->new(app => shift);
       weaken $commands->{app};
       return $commands;
    };
    ...
    sub start { shift->commands->run(@_ ? @_ : @ARGV) }
    #+END_SRC
*** 使用Mojolicious::Commands类的run方法执行
   commands现在的app属性已经设置为MyApp.
   #+BEGIN_SRC perl :eval no
    sub run {
      my ($self， $name， @args) = @_;
    
      ...
      # Run command
      if ($name && $name =~ /^\w+$/ && ($name ne 'help' || $args[0])) {
    
        # Help
        $name = shift @args if my $help = $name eq 'help';
        $help = $ENV{MOJO_HELP} = $ENV{MOJO_HELP} ? 1 : $help;
    
        my $module;
        $module = _command("${_}::$name"， 1) and last for @{$self->namespaces};
    
        # Unknown command
        die qq{Unknown command "$name"， maybe you need to install it?\n}
          unless $module;
    
        # Run command
        my $command = $module->new(app => $self->app);
        return $help ? $command->help(@args) : $command->run(@args);
      }
      ...
    #+END_SRC
    调用\_command加载对应的command模块，我们传的是"daemon"命令，所以此处name为daemon，加载Mojolicious::Command::daemon，然后，实例化一个实例，设置app属性为MyApp，调用其run方法
*** 调用Mojolicious::Command::daemon的run方法
    #+BEGIN_SRC perl :eval no
    sub run {
      my ($self， @args) = @_;
    
      my $daemon = Mojo::Server::Daemon->new(app => $self->app);
      GetOptionsFromArray \@args，
        'b|backlog=i'    => sub { $daemon->backlog($_[1]) }，
        'c|clients=i'    => sub { $daemon->max_clients($_[1]) }，
        'g|group=s'      => sub { $daemon->group($_[1]) }，
        'i|inactivity=i' => sub { $daemon->inactivity_timeout($_[1]) }，
        'l|listen=s'     => \my @listen，
        'p|proxy' => sub { $ENV{MOJO_REVERSE_PROXY} = 1 }，
        'r|requests=i' => sub { $daemon->max_requests($_[1]) }，
        'u|user=s'     => sub { $daemon->user($_[1]) };
    
      $daemon->listen(\@listen) if @listen;
      $daemon->run;
    }
    #+END_SRC
   可以看到实例化了一个Mojo::Server::Daemon类，然后从参数中设置实例的一些属性，设置实例的listen属性.执行run方法启动server.
*** Mojo::Server::Daemon执行run方法
    #+BEGIN_SRC perl :eval no
    sub run {
      my $self = shift;
      local $SIG{INT} = local $SIG{TERM} = sub { $self->ioloop->stop };
      $self->start->setuidgid->ioloop->start;
    }
    #+END_SRC
    注册了一些信号处理后，调用start方法，调用setuidgid创建新session，然后启动ioloop.
*** Mojo::Server::Daemon的start方法
    #+BEGIN_SRC perl :eval no
    sub start {
      my $self = shift;
    
      # Resume accepting connections
      my $loop = $self->ioloop;
      if (my $acceptors = $self->{acceptors}) {
        push @$acceptors， $loop->acceptor(delete $self->{servers}{$_})
          for keys %{$self->{servers}};
      }
    
      # Start listening
      else { $self->_listen($_) for @{$self->listen} }
      $loop->max_connections($self->max_clients);
    
      return $self;
    }
    #+END_SRC   
    分两种情况:
     - 已经打开了监听socket， 每个acceptor对应一个Mojo::IOLoop::Server实例
     - 还没有监听，则调用_listen方法在每个要监听的端口上面开启监听，这样每个端口上启动了一个Mojo::IOLoop::Server实例
*** 调用\_listen方法创建监听的server
    #+BEGIN_SRC perl :eval no
    sub _listen {
      my ($self， $listen) = @_;
      ...
      my $id = $self->ioloop->server(
        $options => sub {
          my ($loop， $stream， $id) = @_;
    
          my $c = $self->{connections}{$id} = {tls => $tls};
          warn "-- Accept (@{[$stream->handle->peerhost]})\n" if DEBUG;
          $stream->timeout($self->inactivity_timeout);
    
          $stream->on(close => sub { $self->_close($id) });
          $stream->on(
            error => sub {
              return unless $self;
              $self->app->log->error(pop);
              $self->_close($id);
            }
          );
          $stream->on(read => sub { $self->_read($id => pop) });
          $stream->on(timeout =>
              sub { $self->app->log->debug('Inactivity timeout.') if $c->{tx} });
        }
      );
      push @{$self->{acceptors} ||= []}， $id;
    
      return if $self->silent;
      $self->app->log->info(qq{Listening at "$listen".});
      $listen =~ s!//\*!//127.0.0.1!i;
      say "Server available at $listen.";
    }
    #+END_SRC
    可以看到是通过实例化Mojo::IOLoop::Server来创建一个监听端口的server，并且将创建的server记录在$self->{acceptors}数组.
*** ioloop被启动
    #+BEGIN_SRC perl :eval no
    sub start {
       my $self = shift;
       croak 'Mojo::IOLoop already running' if $self->is_running;
       (ref $self ? $self : $self->singleton)->reactor->start;
    }
    #+END_SRC
    执行reactor的start方法:
    #+BEGIN_SRC perl :eval no
    # 如果Reactor是Mojo::Reactor::EV
    sub start {EV::run}
    # 如果是Mojo::Reactor::Poll
    sub start {
        my $self = shift;
        return if $self->{running}++;
        $self->one_tick while $self->{running};
    }
    #+END_SRC
    注意到如果是EV，执行run方法会被阻塞，进入了事件循环.如果是Poll，进入了轮询，也是一个循环.

自此server启动完毕

** 总结
   - App的start方法启动app
   - App由commands启动，commands对应于各个server类型(如daemon对应与Mojo::Server::Daemon)
   - commands使用对应的Mojo::Server子类打开监听端口，启动ioloop等待请求到来
   - 多个进程对同一个监听端口的事件处理注册通过文件锁来互斥
   - 每个新进的链接都被封装成一个Mojo::IOLoop::Stream
   - App创建实例的时候会调用startup方法，应用程序通过重载此方法来个性化路由，试图，等等其它所有事情(几乎是唯一入口)
   - 自动检测底层事件发生器的类型:EV或者Poll.优先使用高效的EV
   - 事件发生器支持:timer，io
   - EventEmitter提供一个注册和触发事件的hub或者桥梁，这里的事件都是自定义事件而不是真实世界的外来事件
   - 一个Transaction表达从request到response的整个过程及其数据.类型有HTTP和WebSocket
   - 请求和相应都被抽象为Message类，分别子类化为Request和Response
   - 请求和响应的内容被抽象为Content，分别有Multipart和Single类型的Content(content包括HTTP头部)
   - HTTP头部字段抽象为Headers
   - 资源(文件，请求体内和响应体的内容等)抽象为Asset，类型有File和Memroy
   - 加载类通过Mojo::Loader
   - 请求URL为Mojo::URL，请求的路径部分:Mojo::Path，请求的参数部分:Mojo::Parameters
