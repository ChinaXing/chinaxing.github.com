#+begin_html
---
date: 2013-01-02
template: tech.jade
title: Mojolicious 学习笔记
category: Perl
change_frequency: monthly
tag: Mojolicious
---
#+end_html

*Mojolicous* : [[http://mojolicio.us/]]

** Mojolicous结构

*** route 路由
   根据request进行路由，可以根据：url,param,format,method等进行路由

*** controller
   - 路由的目的地是controller中的某个action，由此action来处理。一个controller一个perl模块，包含多个action作为subrutine。  
   - controller是Mojolicious::Controller的子类。  
   - 默认的controller是Mojolicious::Controller,通过$app->controller\_class('PeSystem::Controller') 设定$app的默认controller.  
   - controller获得app: *$self->app*
   - controller获得请求: *$self->req*
   - controller获得路由匹配的参数: *$self->stash('id')*
   - controller的一些helpers:Mojolicious::Plugin::Defaulthelps，它包含dumper,stash,url\_encode等方法方便使用(*$self->stash('a'=>'b')*)

*** action  
   - action是controller内的子过程。操作都是在action内进行的.  
   - 渲染页面: *$self->render('...'),$self->render\_exception,$self->redirect\_to(...),$self->render*,如果controller没有显式渲染，controller返回后页面会被自动渲染。

*** template  
  - 模版，根据format的不通会自动选择不通的模版:$namespace/$controller/$action.$format.ep, ep结尾表示mojo的内置模版类型（可以嵌入perl）  
  - 异常模版: exception.$mode.$format.ep,exception.$format.ep, $mode为mojo运行的模式（如production,development）
  - 404模版:not\_found.$mode.$format.ep,not\_found.$format.ep

*** 异常
  - Mojo::Exception 是其异常类  
  - Mojo是通过local $SIG{\_\_DIE\_\_}来注册自己的异常捕获的。  
  - 主动抛出异常用die "string",用Mojo::Exception->throw('string')不会携带上下文信息.  
  - controller的render\_exception用来渲染异常页面，它会示例化Mojo::Exception类，然后渲染，同样也不会带上下文信息，所以建议不主动使用.  
  - 捕获异常: 
    #+begin_src perl
       eval { code } or do { die "xxx" }  
    #+end_src
  - 返回异常页面: $self->render_exception(...);

*** helper
  - 辅助工具，默认的/自带的Mojolicious::Plugin::DefaultHelpers 包含stash,dumper等方法.  
  - 也可以自己方便地写helper。
  
*** plugin
  - 插件，许多功能通过插件来添加到Mojo.如Config插件，  
  - 使用插件：
    #+begin_src perl
       $self->app->plugin('Config',{file => 'pesystem.conf')  
    #+end_src
*** hook
  埋点和回调，可以在请求处理和响应的各个阶段进行回调函数的挂入来完成高级自定义。如Exception的处理就是hook来实现的。
  Hook点有:
  - after_build_tx
  - before_dispatch
  - after_static
  - before_routes
  - after_render
  - after_dispatch
  - around_dispatch
  
*** command 模块
  - 提供命令行选项功能和启动app的功能。

*** daemon 模块
  - 实现daemon，继承了command模块。
  - 是单进程实例.

*** Prefork 模块
  - 多进程实例,但是进程数固定.

*** Hypnotoad模块
  - 实现服务器进程，热部署，websocket支持，非阻塞服务器。
  - 使用prefork 实现了多进程(固定进程数,类似nginx worker).

*** websocket
  mojolicious 支持websocket, websocket 和 HTTP一样是一种transaction类型, 此外还有Https.

*** CGI，PSGI
  mojolicious 支持部署方式为PSGI。Plack 启动mojolicious程序则使用PSGI协议.

*** Test::Mojo
  测试模块, Mojolicious 应用测试基类,方便测试.

*** Useragent模块
  - 模拟UserAgent. 支持同步和异步的请求方式.
  - 每个controller有一个UserAgent实例,可以通过$self->ua获取.
  - 每个UserAgent有一个app属性,request,response属性等等: $self->app, $self->req, $self->res
  - UserAgent 使用和依赖了Mojo::IOLoop完成具体任务,使用Mojo::Transaction来构建请求事务.

*** auto-reboot
   morbo 启动mojolicious app 则会检测代码变化，然后自动reload ,一般用在开发环境

** Web开发实践
*** 数据库访问
  使用DBIx::Class
  - DBIx::Class 提供ORM层功能.
  - DBIx::Class 可以将schema和数据库DDL之间转换,互相生成.
  - DBIx::Class 提供版本功能.(我还没有使用)
  - DBIx::Class 有缓冲功能
  - AnyEvent::DBI 提供异步的数据库请求机制, 没有发现DBIx::Class的.

*** Form表单
  使用HTML::FormHandler
  - Form绘制,提供多种widget和theme(Bootstrap主题), 可以通过指定subroutine或hash之类的配置进行配置,可配置性好
  - Form的Validation
  - Form的解析
  
  数据库相关表单使用HTML::FormHandler::TraitFor::Model::DBIC
  - 根据DBIx::Class Schema描述生成Form
  - Form进行Validate后,进行DB的update.
  - 根据relationship关系,自动获取关联关系的Form元素.可以处理relationship.

*** Cache缓冲
  使用插件Mojolicious::Plugin::CHI
  - 它使用[[http://search.cpan.org/perldoc?CHI][CHI]] 做缓冲系统 CHI缓冲系统可以支持很多的存储后端:内存,文件,数据库等等

*** 日期时间:
  使用CoreModule: Time::Piece 和 Time::Seconds
  - Time::Seconds : ONE_DAY, ONE_MIN , $s->sencods ... 提供秒到各个单位的转换.
  - Time::Piece   : 提供localetime 函数, 返回本地时间, 2个Time::Piece对象的差结果是Time::Seconds对象.

*** 国际化i18n
  使用插件Mojolicious::Plugin::I18N
  - 自定义I18N类,通过配置此插件,然后在需要国际化的地方调用: $self->l, 如果是模版内,可以使用helper: l 
  - I18N类,继承Locale::Maketext,然后进行Hack,见其Perldoc

  使用插件Mojolicious::Plugin::Human
  - 导出很多helper:human_datetime,human_date... 方便进行变量的本地化和人性化查看的转换. 如: human_datetime $now

*** 访问日志AccessLog
  使用插件Mojolicious::Plugin::AccessLog
  - 可以定义日志的位置,日志的format,默认使用类似apache logformat的combinded格式.

*** 错误日志ErrorLog
  - mojolicious应用的模块目录下建立log目录,app启动的时候自动生成日志在此目录:$mode.log, 如development.log

*** Hypontoad配置
  可以在app的配置文件中进行如下配置:
  #+begin_src perl
  {
     hypontoad => { listen => ['http://*:9999'], worker => 4 },
  }
  #+end_src

*** 执行外部命令/Fork进程
  使用插件Mojolicious::Plugin::Process
  - 可以以异步方式执行外部命令和程序

*** 目录autoindex
  使用插件Mojolicious::Plugin::Directory
  - 当访问目录的时候，自动内部重定向为/index.html, index.html等文件，类似apache/nginx的autoindex模块功能
  - 此模块还可以针对目录生成目录索引，类似apache/nginx的目录浏览功能

*** 获取时间
  Mojo::Util::steady\_time
  - 使用Time::HiRes模块获得的当前高精度时间
  - Mojo自带的,可以方便的计算耗时

*** 字符串操作
  Mojo::Util模块
  - trim, 删除首尾的空白符
  - squish, 删除首尾的空白符,并且合并行中的连续空白符
  - md5\_bytes,md5\_sum,sha1\_bytes,sha1\_sum,b64\_decode,b64\_encode,encode,decode

*** 给类添加方法或者函数
  Mojo::Util::mokey\_patch
  #+BEGIN_SRC perl eval:no
  # 给调用者添加名为del的方法或者函数(见Mojolicious::Lite源码)
  monkey_patch $caller, del => sub { $routes->delete(@_) };
  #+END_SRC

*** 调整最大允许消息体大小
  Mojo允许的最大消息体（HTTP响应体或请求体）大小为：
  #+BEGIN_SRC perl :eval no
  has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} || 5242880 };
  #+END_SRC
  设置于Mojo::Message 模块中。\\
  下面是如何根据需要调整此值的示例
  #+BEGIN_SRC perl :eval no
  my $tx = $self->ua->build_tx( GET => $self->app->config->{VIPINFO_UPDATE_API} );
    $tx->res->max_message_size(7000000); # here
    $self->ua->start($tx, sub { ... });
  #+END_SRC
