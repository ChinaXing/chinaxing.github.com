#+BEGIN_HTML
---
date: 2015-01-11 18:46:11
template: tech.jade
title: Haskell 第一课 —— 基础
category: Haskell
chage_frequency: monthly
tag: Haskell
---
#+END_HTML
#+OPTIONS: toc:nil
#+TOC: headlines 2
** Haskell 特点
+ static Type :: 静态类型，类型可在编译时候明确，不存在运行时器的类型确定。带来的好处是类型安全，不会出现运行期的类型错误。
+ type infer :: 类型推导，编译器和运行系统自己可以根据上下文明确每个变量和函数的类型，不需要每处都显式的书写类型。带来的好处是可以减少输入。
+ lazy evaluate :: 延迟计算，计算和求值会推迟到需要的时候才进行，好处是可以减少不必要的运算等。
+ lazy IO Action :: IO 动作只有在需要的时候才触发，而且是按需触发。
+ curry / partial :: 每个haskell函数只有一个参数，多参数的函数可以通过curry化，转换为新的单参数函数，curry 化是partial applicate函数的部分参数来获得。
+ partern match :: 根据模式匹配来进行函数的路由，是实现分支和递归的利器。这也几乎是所有函数语言的特点之一。
+ TypeClass :: 类型的类型，若干类型可以具有某种特点（类型），这个类型的类型就是TypeClass，类比于Java的Interface。
+ Type varaible :: 一种抽象类型可以具有类型变量，类似于java generic和c++ template。
+ composition function :: 复合函数，多个函数可以复合，实现函数链条 (f . g) x = f(g x) 。 
+ Recursion :: 使用递归思想取代使用循环的命令式思想，将问题的求解转换为递归到边界条件的运算。
+ Guard :: guard 是模式匹配的增强版本，guard对参数进行路由，实现了分支。
+ fold :: fold 代替递归，fold 本质是一种迭代，使用foldr。
+ flip :: 将参数对换: flip f x y = f y x 或 flip f = \x y -> f y x
+ lambda :: 一种匿名函数，便捷函数
+ syntax :: 变量小写开头，类型大写开头

** haskell 模块
+ module定义 :: 使用module Ma (expors...) where ... 开始来定义一个文件内容为模块。
+ module引用 :: import Ma 来导入模块内部的函数和类型

** haskell 类型
+ 定义类型 
  #+BEGIN_SRC haskell
    data T1 a b = Constructor1 a | Consutructor2 a b -- with type varaible
    data Circle = Circle r -- normal
    data Rectangle = Rectangle { width :: Int , height :: Int } -- record style
  #+END_SRC
  * 类型构造器是一个函数或者是一个类型常量（如果没有参数）
  * 类型定义支持递归定义，递归数据结构
  * 对于复杂类型，最好使用record模式，这样，访问器自动生成。
+ 类型别名
  #+BEGIN_SRC haskell
     type UserName = String -- simple
     type StringArray = [String] -- yet another
     type IntMap = Map.Map Int -- from abstract Type
  #+END_SRC

** To be haskellism
+ 使用Maybe返回函数的结果，避免抛出异常
+ 使用Either返回函数结果，如果你在乎出错原因的话
+ 使用foldr代替定义递归
+ 使用组合函数代替括号和lambda
