#+BEGIN_HTML
---
date: 2015-01-11 20:39:10
template: tech.jade
title: Haskell 第二课 —— 类型
category: Haskell
chage_frequency: monthly
tag: Haskell
---
#+END_HTML

** Type
   #+BEGIN_SRC haskell
      data Maybe a = Nothing | Just a
   #+END_SRC
   + Maybe :: type constructor
   + Nothing :: variable constructor
   + Just a :: variable constructor
   + a :: type varaible

** Type partial
   #+BEGIN_SRC haskell
     type MaybeInt = Maybe Int
     type EitherInt = Either Int
     type EitherIntString = EitherInt String
   #+END_SRC

** TypeClass
   #+BEGIN_SRC haskell
     class YesNo a where
          yesno :: a -> Bool
   #+END_SRC
   
   + YesNo :: typeClass
   + a :: type variable
   + yesno :: typeClass function
** newType
   #+BEGIN_SRC haskell
     newtype CoolBool = CoolBool { getCoolBool :: Bool}
   #+END_SRC
  
   + 定义一种已有类型的wrap或者具化
   + haskell 不会真正创建类型，开销小
** Functor
   #+BEGIN_SRC  haskell
     class  Functor f where 
        fmap :: (a -> b) -> f a -> f b
   #+END_SRC
   
   + f :: type constructor
   + a :: type varaible a
   + b :: type variable b
   + f a :: type construct by : f a (eg. Maybe Int)
   + f b :: same
** Kind
   类型有Kind，即类型本身的类型，通过使用ghci 的:k 功能，可以查阅到某个类型的Kind:
   #+BEGIN_SRC haskell
    :k Maybe
    Maybe :: * -> *
    :k Int
    Int :: *
    :k Maybe Int
    Maybe Int :: *
    :k Either
    Either :: * -> * -> *
    :k Either Int
    Either Int :: * -> *
   #+END_SRC
   + '*' 代表一concrete（明确）的类型，只有明确的类型才能用作变量的类型，其它类型是抽象类型或者说类型的模板
   + * -> * 代表一一个类型构造器，或者说参数化的类型，它接收一个明确类型为参数，然后构造出一个明确类型
   类型的构造器如果有多个参数（Either），那么就可以curry化，即部分应用明确类型后，生成出一个新的类型构造器
** (->) r
   #+BEGIN_SRC haskell
     instance Functor ((->) r) where
       fmap :: (a->b) -> (r -> a) -> (r -> b)
       # fmap = .
   #+END_SRC
** Applicative
   *Control.Applicative*
   #+BEGIN_SRC haskell
     class Functor f => Applicative (f :: * -> *) where
       pure a = f a
       <*> :: f (a -> b) -> f a -> f b 
       <$> :: (a -> b) -> f a -> f b
   #+END_SRC
   #+BEGIN_SRC haskell
     instance Applicative ((->) r) where 
        pure a x = \_ -> x
        (f <*> g) x = f (g x) x
        f <$> g = f . g 
    -- prove
    f (a->b) = \x -> \a -> b = \x -> \a -> (h a) x -- h (a,x)
    f a = \x' -> a = \x' -> k x'
    f (a->b) <*> f a = \x' -> \a -> (h a) (k x') = \x' -> (h x')(k x') = ( h . k $ x ) $ x
    (a->b) = \x -> b = h x
    f a = \x' -> a = g x'
    (a->b) <$> f a = \x' -> h (g x') = \x' -> h . g $ x'
    #+END_SRC
** liftA2
   #+BEGIN_SRC haskell
     liftA2 :: f (a -> b -> c) -> f a -> f b -> f c
   #+END_SRC
** Monoid
   *Data.Monoid*
   #+BEGIN_SRC haskell
     class Monoid m where
       mempty  :: m
       mappend :: m -> m -> m
       mconcat :: [m] -> m
       mconcat :: foldr mappend mempty
   #+END_SRC
